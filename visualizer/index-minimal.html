<!DOCTYPE html>
<!-- aurasecurity v1.2.2 - 2026-01-26 - Attack Paths breakdown -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>aurasecurity</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --border: #30363d;
      --border-light: #484f58;
      --text-primary: #e6edf3;
      --text-secondary: #8b949e;
      --text-muted: #6e7681;
      --accent: #58a6ff;
      --accent-subtle: rgba(56, 139, 253, 0.15);
      --critical: #f85149;
      --critical-subtle: rgba(248, 81, 73, 0.15);
      --high: #db6d28;
      --high-subtle: rgba(219, 109, 40, 0.15);
      --warning: #d29922;
      --warning-subtle: rgba(210, 153, 34, 0.15);
      --success: #3fb950;
      --success-subtle: rgba(63, 185, 80, 0.15);
    }

    body {
      background: var(--bg-primary);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text-primary);
      overflow: hidden;
      min-height: 100vh;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* 3D Hover Tooltip */
    #tooltip3d {
      position: fixed;
      z-index: 200;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s;
      max-width: 280px;
    }

    #tooltip3d.visible {
      opacity: 1;
    }

    #tooltip3d .tooltip-name {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      font-size: 13px;
    }

    #tooltip3d .tooltip-stats {
      display: flex;
      gap: 12px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    #tooltip3d .tooltip-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #tooltip3d .tooltip-stat.critical { color: var(--critical); }
    #tooltip3d .tooltip-stat.warning { color: var(--warning); }
    #tooltip3d .tooltip-stat.safe { color: var(--success); }

    #tooltip3d .tooltip-hint {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 6px;
      border-top: 1px solid var(--border);
      padding-top: 6px;
    }

    /* 3D Navigation Breadcrumb */
    #nav3d {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 150;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }

    #nav3d.visible {
      opacity: 1;
      pointer-events: auto;
    }

    #nav3d .nav-item {
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.15s;
    }

    #nav3d .nav-item:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    #nav3d .nav-item.active {
      color: var(--accent);
      font-weight: 500;
    }

    #nav3d .nav-sep {
      color: var(--text-muted);
    }

    #nav3d .back-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
      margin-right: 8px;
      transition: all 0.15s;
    }

    #nav3d .back-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Panels */
    .panel {
      position: fixed;
      z-index: 100;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
    }

    /* Header */
    #header {
      top: 0;
      left: 0;
      right: 0;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      background: var(--bg-secondary);
      border-radius: 0;
      border-top: none;
      border-left: none;
      border-right: none;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      font-weight: 600;
    }

    .logo-icon {
      height: 24px;
      width: auto;
    }

    .logo-icon img {
      height: 100%;
      width: auto;
    }

    .home-link {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.15s;
      margin-left: 16px;
    }

    .home-link:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border-color: var(--border-light);
    }

    .home-link svg {
      width: 14px;
      height: 14px;
    }

    .nav-tabs {
      display: flex;
      gap: 4px;
      background: var(--bg-tertiary);
      padding: 4px;
      border-radius: 6px;
    }

    .nav-tab {
      padding: 6px 16px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-family: inherit;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      border-radius: 4px;
    }

    .nav-tab:hover {
      color: var(--text-primary);
      background: var(--bg-secondary);
    }

    .nav-tab.active {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .header-stats {
      display: flex;
      gap: 16px;
      font-size: 13px;
    }

    .header-stat {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--text-secondary);
    }

    .stat-value {
      font-weight: 600;
      color: var(--text-primary);
    }

    .stat-value.critical { color: var(--critical); }
    .stat-value.warning { color: var(--warning); }

    /* Score Display */
    .score-display {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 16px;
      border-left: 1px solid var(--border);
      margin-left: 8px;
    }

    .score-circle {
      position: relative;
      width: 40px;
      height: 40px;
    }

    .score-circle svg {
      transform: rotate(-90deg);
    }

    .score-circle .score-bg {
      fill: none;
      stroke: var(--bg-tertiary);
      stroke-width: 3;
    }

    .score-circle .score-progress {
      fill: none;
      stroke: var(--success);
      stroke-width: 3;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.5s ease, stroke 0.3s;
    }

    .score-value-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    .score-number {
      font-size: 12px;
      font-weight: 700;
      color: var(--text-primary);
      line-height: 1;
    }

    .score-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .score-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .score-grade {
      font-size: 18px;
      font-weight: 700;
    }

    .score-grade.grade-a { color: var(--success); }
    .score-grade.grade-b { color: var(--accent); }
    .score-grade.grade-c { color: var(--warning); }
    .score-grade.grade-f { color: var(--critical); }

    .score-trend {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
    }

    .score-trend.up { color: var(--success); }
    .score-trend.down { color: var(--critical); }
    .score-trend.same { color: var(--text-muted); }

    .trend-chart-mini {
      width: 60px;
      height: 24px;
    }

    .trend-chart-mini polyline {
      fill: none;
      stroke: var(--accent);
      stroke-width: 1.5;
    }

    /* Left Panel - Scanner */
    #scanner-panel {
      top: 72px;
      left: 16px;
      width: 320px;
      max-height: calc(100vh - 88px);
      overflow-y: auto;
    }

    .section-header {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }

    .input-group {
      margin-bottom: 12px;
    }

    .input-group label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }

    .input-group input {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 13px;
      transition: border-color 0.15s;
    }

    .input-group input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .input-group input::placeholder {
      color: var(--text-muted);
    }

    .btn {
      width: 100%;
      padding: 10px 16px;
      background: var(--accent);
      border: none;
      border-radius: 6px;
      color: white;
      font-family: inherit;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      margin-top: 8px;
    }

    .btn:hover {
      background: #4c9aff;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn-danger {
      background: var(--critical-subtle);
      color: var(--critical);
    }

    .btn-danger:hover {
      background: rgba(248, 81, 73, 0.25);
    }

    /* Scanned repos list */
    .repo-list {
      margin-top: 16px;
    }

    .repo-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .repo-item:hover {
      border-color: var(--border-light);
    }

    .repo-item.selected {
      border-color: var(--accent);
      background: var(--accent-subtle);
    }

    .repo-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .repo-status.critical { background: var(--critical); }
    .repo-status.warning { background: var(--warning); }
    .repo-status.safe { background: var(--success); }

    .repo-info { flex: 1; min-width: 0; }
    .repo-name { font-size: 13px; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .repo-path { font-size: 11px; color: var(--text-muted); margin-top: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .repo-stats { font-size: 11px; color: var(--text-secondary); }

    /* Right Panel - Details */
    #details-panel {
      top: 72px;
      right: 16px;
      width: 360px;
      max-height: calc(100vh - 88px);
      overflow-y: auto;
    }

    .selected-repo-header {
      display: none;
      padding: 12px;
      background: var(--bg-primary);
      border-radius: 6px;
      margin-bottom: 16px;
    }

    .selected-repo-header.visible { display: block; }
    .selected-repo-name { font-size: 14px; font-weight: 500; }
    .selected-repo-path { font-size: 12px; color: var(--text-muted); margin-top: 4px; }

    .finding-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .finding-item {
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      border-left: 3px solid;
    }

    .finding-item.critical { border-left-color: var(--critical); background: var(--critical-subtle); }
    .finding-item.high { border-left-color: var(--high); background: var(--high-subtle); }
    .finding-item.medium { border-left-color: var(--warning); background: var(--warning-subtle); }
    .finding-item.low { border-left-color: var(--success); background: var(--success-subtle); }

    .finding-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .finding-severity {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .finding-item.critical .finding-severity { color: var(--critical); }
    .finding-item.high .finding-severity { color: var(--high); }
    .finding-item.medium .finding-severity { color: var(--warning); }
    .finding-item.low .finding-severity { color: var(--success); }

    .finding-type {
      font-size: 10px;
      color: var(--text-muted);
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .finding-message {
      font-size: 13px;
      color: var(--text-primary);
      margin-bottom: 6px;
      line-height: 1.4;
    }

    .finding-file {
      font-size: 11px;
      color: var(--text-muted);
      font-family: 'SF Mono', Monaco, monospace;
    }

    /* Reports Panel */
    #reports-panel {
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      width: 900px;
      max-width: calc(100% - 40px);
      max-height: calc(100vh - 88px);
      overflow-y: auto;
      display: none;
    }

    #reports-panel.active { display: block; }

    /* Rug Check Panel */
    #rugcheck-panel {
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      width: 600px;
      max-width: calc(100% - 40px);
      max-height: calc(100vh - 88px);
      overflow-y: auto;
      display: none;
    }

    #rugcheck-panel.active { display: block; }

    /* Intel Panel - CVE Alerts */
    #intel-panel {
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      width: 700px;
      max-width: calc(100% - 40px);
      max-height: calc(100vh - 88px);
      overflow-y: auto;
      display: none;
    }

    #intel-panel.active { display: block; }

    .intel-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .intel-title {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .intel-subtitle {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .intel-search {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
    }

    .intel-search input {
      flex: 1;
      padding: 12px 16px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 14px;
    }

    .intel-search button {
      padding: 12px 20px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
    }

    .cve-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .cve-card {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
    }

    .cve-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .cve-id {
      font-weight: 600;
      color: var(--accent);
      font-family: monospace;
    }

    .cve-cvss {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
    }

    .cve-cvss.critical { background: var(--critical-subtle); color: var(--critical); }
    .cve-cvss.high { background: var(--high-subtle); color: var(--high); }
    .cve-cvss.medium { background: var(--warning-subtle); color: var(--warning); }
    .cve-cvss.low { background: var(--success-subtle); color: var(--success); }

    .cve-title {
      font-size: 14px;
      margin-bottom: 8px;
    }

    .cve-meta {
      display: flex;
      gap: 16px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .trending-header {
      font-size: 16px;
      font-weight: 600;
      margin: 24px 0 12px 0;
      color: var(--text-primary);
    }

    /* Attack Paths Panel */
    #attack-panel {
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      width: 800px;
      max-width: calc(100% - 40px);
      max-height: calc(100vh - 88px);
      overflow-y: auto;
      display: none;
    }

    #attack-panel.active { display: block; }

    .attack-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .attack-title {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .attack-subtitle {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .attack-path-card {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 12px;
    }

    .attack-path-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .attack-path-name {
      font-weight: 600;
      font-size: 16px;
    }

    .attack-path-risk {
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
    }

    .attack-path-risk.critical { background: var(--critical-subtle); color: var(--critical); }
    .attack-path-risk.high { background: var(--high-subtle); color: var(--high); }
    .attack-path-risk.medium { background: var(--warning-subtle); color: var(--warning); }

    .attack-path-steps {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .attack-step {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 12px;
      background: var(--bg-secondary);
      border-radius: 6px;
    }

    .attack-step-num {
      width: 24px;
      height: 24px;
      background: var(--accent);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .attack-step-text {
      font-size: 13px;
    }

    .attack-step-arrow {
      text-align: center;
      color: var(--text-muted);
      font-size: 16px;
    }

    .mitre-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 12px;
    }

    .mitre-tag {
      padding: 4px 8px;
      background: var(--accent-subtle);
      color: var(--accent);
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
    }

    .attack-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .attack-btn {
      padding: 8px 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 12px;
    }

    .attack-btn:hover {
      background: var(--bg-tertiary);
    }

    .attack-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .rugcheck-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .rugcheck-title {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .rugcheck-subtitle {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .rugcheck-input-section {
      margin-bottom: 24px;
    }

    .rugcheck-input {
      width: 100%;
      padding: 14px 16px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 14px;
      margin-bottom: 12px;
    }

    .rugcheck-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .rugcheck-btn {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .rugcheck-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
    }

    .rugcheck-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* Trust Score Circle */
    .trust-score-section {
      text-align: center;
      margin: 32px 0;
    }

    .trust-score-circle {
      width: 160px;
      height: 160px;
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px;
      position: relative;
    }

    .trust-score-circle::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      padding: 4px;
      background: linear-gradient(135deg, var(--score-color-1) 0%, var(--score-color-2) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
    }

    .trust-score-circle.grade-a {
      --score-color-1: #3fb950;
      --score-color-2: #238636;
    }

    .trust-score-circle.grade-b {
      --score-color-1: #58a6ff;
      --score-color-2: #1f6feb;
    }

    .trust-score-circle.grade-c {
      --score-color-1: #d29922;
      --score-color-2: #9e6a03;
    }

    .trust-score-circle.grade-f {
      --score-color-1: #f85149;
      --score-color-2: #da3633;
    }

    .trust-score-number {
      font-size: 48px;
      font-weight: 700;
      line-height: 1;
    }

    .trust-score-grade {
      font-size: 20px;
      font-weight: 600;
      opacity: 0.8;
    }

    /* Verdict Banner */
    .verdict-banner {
      padding: 16px;
      border-radius: 8px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 1px;
      margin-bottom: 16px;
    }

    .verdict-banner.safu {
      background: rgba(63, 185, 80, 0.15);
      color: #3fb950;
      border: 1px solid rgba(63, 185, 80, 0.3);
    }

    .verdict-banner.dyor {
      background: rgba(88, 166, 255, 0.15);
      color: #58a6ff;
      border: 1px solid rgba(88, 166, 255, 0.3);
    }

    .verdict-banner.risky {
      background: rgba(210, 153, 34, 0.15);
      color: #d29922;
      border: 1px solid rgba(210, 153, 34, 0.3);
    }

    .verdict-banner.rug-alert {
      background: rgba(248, 81, 73, 0.15);
      color: #f85149;
      border: 1px solid rgba(248, 81, 73, 0.3);
    }

    /* Quick Stats */
    .quick-stats {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }

    .quick-stat {
      padding: 8px 14px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
    }

    .quick-stat.good {
      background: rgba(63, 185, 80, 0.15);
      color: #3fb950;
    }

    .quick-stat.warn {
      background: rgba(210, 153, 34, 0.15);
      color: #d29922;
    }

    .quick-stat.bad {
      background: rgba(248, 81, 73, 0.15);
      color: #f85149;
    }

    .quick-stat.info {
      background: rgba(88, 166, 255, 0.15);
      color: #58a6ff;
    }

    /* Checks List */
    .checks-section {
      margin-bottom: 24px;
    }

    .checks-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .check-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px;
      background: var(--bg-primary);
      border-radius: 6px;
      margin-bottom: 8px;
      border-left: 3px solid;
    }

    .check-item.good {
      border-left-color: #3fb950;
    }

    .check-item.warn {
      border-left-color: #d29922;
    }

    .check-item.bad {
      border-left-color: #f85149;
    }

    .check-item.info {
      border-left-color: #58a6ff;
    }

    .check-icon {
      font-size: 16px;
      flex-shrink: 0;
    }

    .check-content {
      flex: 1;
    }

    .check-name {
      font-weight: 500;
      font-size: 13px;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .check-explanation {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Summary Section */
    .summary-section {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
    }

    .summary-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .summary-text {
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-primary);
    }

    /* Metrics Grid */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-top: 24px;
    }

    .metric-card {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      text-align: center;
    }

    .metric-value {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .metric-label {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    /* Fixes Section */
    .fixes-section {
      margin-top: 20px;
      border-top: 1px solid var(--border);
      padding-top: 16px;
    }

    .fixes-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .fixes-title {
      font-weight: 600;
      font-size: 13px;
      color: var(--text-primary);
    }

    .fixes-summary {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
      font-size: 12px;
    }

    .fixes-stat {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    .fixes-stat.fixable { color: var(--success); }
    .fixes-stat.unfixable { color: var(--text-muted); }

    .fix-command-box {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .fix-command-label {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    .fix-command {
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 11px;
      color: var(--success);
      word-break: break-all;
      max-height: 80px;
      overflow-y: auto;
    }

    .fix-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .fix-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      border-bottom: 1px solid var(--border);
      font-size: 12px;
    }

    .fix-item:last-child {
      border-bottom: none;
    }

    .fix-icon {
      font-size: 14px;
    }

    .fix-package {
      font-weight: 500;
      color: var(--text-primary);
    }

    .fix-version {
      color: var(--text-muted);
    }

    .fix-arrow {
      color: var(--success);
    }

    .fix-new-version {
      color: var(--success);
      font-weight: 500;
    }

    .btn-fix {
      background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
      border: 1px solid #238636;
    }

    .btn-fix:hover {
      background: linear-gradient(135deg, #2ea043 0%, #3fb950 100%);
    }

    .btn-fix:disabled {
      background: var(--bg-tertiary);
      border-color: var(--border);
      color: var(--text-muted);
      cursor: not-allowed;
    }

    .fixes-loading {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-secondary);
      font-size: 12px;
    }

    .fixes-loading .spinner {
      width: 14px;
      height: 14px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .fixes-error {
      background: var(--critical-subtle);
      border: 1px solid var(--critical);
      border-radius: 6px;
      padding: 12px;
      font-size: 12px;
    }

    .fixes-error-title {
      color: var(--critical);
      font-weight: 500;
      margin-bottom: 4px;
    }

    .fixes-error-msg {
      color: var(--text-secondary);
    }

    .fixes-error code {
      display: block;
      margin-top: 8px;
      padding: 8px;
      background: var(--bg-primary);
      border-radius: 4px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 11px;
      color: var(--text-primary);
    }

    .report-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .report-actions .btn {
      width: auto;
      padding: 8px 14px;
    }

    .report-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .report-table th,
    .report-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    .report-table th {
      color: var(--text-secondary);
      font-weight: 500;
      font-size: 12px;
    }

    .report-table tr:hover td {
      background: var(--bg-tertiary);
    }

    /* View Info */
    #view-info {
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      font-size: 12px;
      text-align: center;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border-radius: 6px;
    }

    #view-info kbd {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      color: var(--text-primary);
    }

    /* Filter toggles */
    .filter-section {
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .filter-label {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .filter-toggles {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .filter-toggle {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 11px;
      font-family: inherit;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }

    .filter-toggle:hover {
      border-color: var(--border-light);
      color: var(--text-primary);
    }

    .filter-toggle.active {
      background: var(--accent-subtle);
      border-color: var(--accent);
      color: var(--accent);
    }

    .filter-toggle.active.critical {
      background: var(--critical-subtle);
      border-color: var(--critical);
      color: var(--critical);
    }

    .filter-toggle.active.high {
      background: var(--high-subtle);
      border-color: var(--high);
      color: var(--high);
    }

    .filter-toggle.active.medium {
      background: var(--warning-subtle);
      border-color: var(--warning);
      color: var(--warning);
    }

    .filter-toggle.active.low {
      background: var(--success-subtle);
      border-color: var(--success);
      color: var(--success);
    }

    .filter-toggle .toggle-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
      opacity: 0.6;
    }

    .filter-toggle.active .toggle-dot {
      opacity: 1;
    }

    .filter-toggle .toggle-count {
      font-weight: 600;
      margin-left: 2px;
    }

    /* Badge generator */
    .badge-section {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .badge-preview {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      padding: 12px;
      background: var(--bg-primary);
      border-radius: 6px;
      justify-content: center;
    }

    .badge-preview img {
      height: 20px;
    }

    .badge-code {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 11px;
      color: var(--text-secondary);
      word-break: break-all;
      margin-bottom: 8px;
    }

    .badge-actions {
      display: flex;
      gap: 6px;
    }

    .badge-actions .btn {
      width: auto;
      padding: 6px 12px;
      font-size: 11px;
      margin-top: 0;
    }

    .copy-success {
      color: var(--success);
      font-size: 11px;
      margin-left: 8px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .copy-success.visible {
      opacity: 1;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 32px 16px;
      color: var(--text-muted);
    }

    .empty-state-icon {
      font-size: 32px;
      margin-bottom: 8px;
      opacity: 0.5;
    }

    .empty-state p {
      font-size: 13px;
    }

    /* Log output */
    .log-output {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      font-size: 12px;
      font-family: 'SF Mono', Monaco, monospace;
      max-height: 140px;
      overflow-y: auto;
      margin-top: 12px;
    }

    .log-line {
      margin-bottom: 4px;
      color: var(--text-secondary);
    }

    .log-line.success { color: var(--success); }
    .log-line.error { color: var(--critical); }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--border-light); }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }
    .modal-content {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      width: 100%;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }
    .modal-header h3 {
      margin: 0;
      font-size: 18px;
    }
    .modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
  </style>
</head>
<body>
  <!-- Three.js 3D Canvas -->
  <div id="canvas-container"></div>

  <!-- 3D Hover Tooltip -->
  <div id="tooltip3d">
    <div class="tooltip-name"></div>
    <div class="tooltip-stats">
      <span class="tooltip-stat critical"><span class="count">0</span> Secrets</span>
      <span class="tooltip-stat warning"><span class="count">0</span> Vulns</span>
    </div>
    <div class="tooltip-hint">Click to view findings in 3D</div>
  </div>

  <!-- 3D Navigation Breadcrumb -->
  <div id="nav3d">
    <button class="back-btn" onclick="navigateBack()">‚Üê Back</button>
    <span class="nav-item" onclick="navigateToLevel(0)">All Repos</span>
    <span class="nav-sep">/</span>
    <span class="nav-item nav-repo"></span>
    <span class="nav-sep nav-sev-sep" style="display:none">/</span>
    <span class="nav-item nav-severity" style="display:none"></span>
  </div>

  <!-- Header -->
  <header id="header" class="panel">
    <div class="logo">
      <div class="logo-icon"><img src="/images/logo.png" alt="AuraSecurity"></div>
      <span>aurasecurity</span>
    </div>

    <a href="https://aurasecurity.io" class="home-link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
        <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/>
      </svg>
      Home
    </a>

    <div class="nav-tabs">
      <button class="nav-tab active" onclick="showView('scan')">Scan</button>
      <button class="nav-tab" onclick="showView('reports')">Reports</button>
      <button class="nav-tab" onclick="showView('rugcheck')">Rug Check</button>
      <button class="nav-tab" onclick="showView('intel')">üîî Intel</button>
      <button class="nav-tab" onclick="showView('attack')">‚öîÔ∏è Attack Paths</button>
    </div>

    <div class="header-stats">
      <div class="header-stat">
        <span class="stat-value critical" id="totalCritical">0</span>
        <span>Secrets</span>
      </div>
      <div class="header-stat">
        <span class="stat-value warning" id="totalWarning">0</span>
        <span>Vulns</span>
      </div>
      <div class="header-stat">
        <span class="stat-value" id="totalRepos">0</span>
        <span>Scanned</span>
      </div>

      <!-- Security Score -->
      <div class="score-display" id="scoreDisplay">
        <div class="score-circle">
          <svg viewBox="0 0 40 40">
            <circle class="score-bg" cx="20" cy="20" r="17"/>
            <circle class="score-progress" id="scoreProgress" cx="20" cy="20" r="17"
                    stroke-dasharray="106.8" stroke-dashoffset="106.8"/>
          </svg>
          <div class="score-value-container">
            <span class="score-number" id="scoreNumber">--</span>
          </div>
        </div>
        <div class="score-info">
          <span class="score-label">Score</span>
          <span class="score-grade grade-a" id="scoreGrade">-</span>
          <span class="score-trend same" id="scoreTrend">--</span>
        </div>
        <svg class="trend-chart-mini" id="trendChartMini" viewBox="0 0 60 24">
          <polyline id="trendLine" points=""/>
        </svg>
      </div>
    </div>
  </header>

  <!-- Scanner Panel (Left) -->
  <div id="scanner-panel" class="panel">
    <div class="section-header">New Scan</div>

    <div class="input-group">
      <label>Local Path</label>
      <input type="text" id="scanPath" placeholder="/path/to/project">
    </div>

    <div class="input-group">
      <label>Git Repository URL</label>
      <input type="text" id="gitUrl" placeholder="https://github.com/user/repo">
    </div>

    <button class="btn" id="scanBtn" onclick="executeScan()">
      Start Scan
    </button>

    <div class="log-output" id="logOutput">
      <div class="log-line">Ready to scan</div>
    </div>

    <div class="section-header" style="margin-top: 20px;">Scanned Targets</div>

    <div class="repo-list" id="repoList">
      <div class="empty-state">
        <div class="empty-state-icon">üìÅ</div>
        <p>No targets scanned yet</p>
      </div>
    </div>
  </div>

  <!-- Details Panel (Right) -->
  <div id="details-panel" class="panel">
    <div class="section-header">Findings</div>

    <div class="selected-repo-header" id="selectedRepoInfo">
      <div class="selected-repo-name" id="selectedRepoName">-</div>
      <div class="selected-repo-path" id="selectedRepoPath">-</div>
    </div>

    <!-- Filter Toggles -->
    <div class="filter-section" id="filterSection" style="display: none;">
      <div class="filter-label">Filter by Severity</div>
      <div class="filter-toggles" id="severityFilters">
        <button class="filter-toggle active critical" data-filter="critical" onclick="toggleFilter('severity', 'critical')">
          <span class="toggle-dot"></span>Critical <span class="toggle-count" id="countCritical">0</span>
        </button>
        <button class="filter-toggle active high" data-filter="high" onclick="toggleFilter('severity', 'high')">
          <span class="toggle-dot"></span>High <span class="toggle-count" id="countHigh">0</span>
        </button>
        <button class="filter-toggle active medium" data-filter="medium" onclick="toggleFilter('severity', 'medium')">
          <span class="toggle-dot"></span>Medium <span class="toggle-count" id="countMedium">0</span>
        </button>
        <button class="filter-toggle active low" data-filter="low" onclick="toggleFilter('severity', 'low')">
          <span class="toggle-dot"></span>Low <span class="toggle-count" id="countLow">0</span>
        </button>
      </div>
      <div class="filter-label" style="margin-top: 12px;">Filter by Type</div>
      <div class="filter-toggles" id="typeFilters">
        <button class="filter-toggle active" data-filter="SECRET" onclick="toggleFilter('type', 'SECRET')">
          <span class="toggle-dot"></span>Secrets
        </button>
        <button class="filter-toggle active" data-filter="VULN" onclick="toggleFilter('type', 'VULN')">
          <span class="toggle-dot"></span>Vulns
        </button>
        <button class="filter-toggle active" data-filter="CODE" onclick="toggleFilter('type', 'CODE')">
          <span class="toggle-dot"></span>Code
        </button>
        <button class="filter-toggle active" data-filter="IAC" onclick="toggleFilter('type', 'IAC')">
          <span class="toggle-dot"></span>IaC
        </button>
        <button class="filter-toggle active" data-filter="DOCKER" onclick="toggleFilter('type', 'DOCKER')">
          <span class="toggle-dot"></span>Docker
        </button>
      </div>
    </div>

    <div class="finding-list" id="findingList">
      <div class="empty-state">
        <div class="empty-state-icon">üîç</div>
        <p>Select a target to view findings</p>
      </div>
    </div>

    <!-- Badge Generator -->
    <div class="badge-section" id="badgeSection" style="display: none;">
      <div class="filter-label">Security Badge</div>
      <div class="badge-preview" id="badgePreview">
        <img id="badgeImg" src="" alt="Security Badge">
      </div>
      <div class="badge-code" id="badgeCode">Select a repo to generate badge</div>
      <div class="badge-actions">
        <button class="btn btn-secondary" onclick="copyBadge('markdown')">Copy Markdown</button>
        <button class="btn btn-secondary" onclick="copyBadge('html')">Copy HTML</button>
        <span class="copy-success" id="copySuccess">Copied!</span>
      </div>
    </div>

    <!-- Fixes Section -->
    <div class="fixes-section" id="fixesSection" style="display: none;">
      <div class="fixes-header">
        <span class="fixes-title">üîß Fix Suggestions</span>
        <div style="display: flex; gap: 8px;">
          <button class="btn btn-fix" id="generateFixesBtn" onclick="generateFixes()">
            Generate Fixes
          </button>
          <button class="btn" id="validateExploitBtn" onclick="validateExploitability()" style="background: var(--critical-subtle); color: var(--critical);">
            ‚ö° Validate Exploitability
          </button>
        </div>
      </div>

      <div id="fixesContent">
        <!-- Will be populated by JavaScript -->
      </div>

      <div id="validationContent" style="margin-top: 16px; display: none;">
        <!-- Will be populated by Red Team validation -->
      </div>
    </div>
  </div>

  <!-- Reports Panel (Center, hidden by default) -->
  <div id="reports-panel" class="panel">
    <div class="section-header">Scan Reports</div>

    <div class="report-actions">
      <button class="btn" onclick="exportReports('json')">Export JSON</button>
      <button class="btn btn-secondary" onclick="exportReports('csv')">Export CSV</button>
      <button class="btn btn-danger" onclick="clearAllReports()">Clear All</button>
    </div>

    <table class="report-table">
      <thead>
        <tr>
          <th>Timestamp</th>
          <th>Target</th>
          <th>Type</th>
          <th>Secrets</th>
          <th>Vulns</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="reportTableBody">
        <tr>
          <td colspan="7" style="text-align: center; color: var(--text-muted);">No reports yet</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Rug Check Panel -->
  <div id="rugcheck-panel" class="panel">
    <div class="rugcheck-header">
      <div class="rugcheck-title">
        <span>üîç</span> Rug Check
      </div>
      <div class="rugcheck-subtitle">Is this crypto project getting rugged?</div>
    </div>

    <div class="rugcheck-input-section">
      <input type="text" id="rugcheckUrl" class="rugcheck-input" placeholder="https://github.com/owner/repo">
      <button class="rugcheck-btn" id="rugcheckBtn" onclick="doRugCheck()">
        Check Project
      </button>
    </div>

    <div id="rugcheckResults" style="display: none;">
      <div class="trust-score-section">
        <div class="trust-score-circle" id="trustScoreCircle">
          <div class="trust-score-number" id="trustScoreNumber">--</div>
          <div class="trust-score-grade" id="trustScoreGrade">-</div>
        </div>
      </div>

      <div class="verdict-banner" id="verdictBanner">
        <span id="verdictText">--</span>
      </div>

      <div class="quick-stats" id="quickStats">
        <!-- Populated by JS -->
      </div>

      <div class="checks-section">
        <div class="checks-title">
          <span>üìã</span> Detailed Checks
        </div>
        <div id="checksList">
          <!-- Populated by JS -->
        </div>
      </div>

      <div class="summary-section">
        <div class="summary-title">What This Means</div>
        <div class="summary-text" id="summaryText">--</div>
      </div>

      <div class="metrics-grid" id="metricsGrid">
        <!-- Populated by JS -->
      </div>
    </div>

    <div id="rugcheckError" style="display: none; text-align: center; padding: 20px; color: var(--critical);">
      <!-- Error message -->
    </div>
  </div>

  <!-- Intel Panel - CVE Alerts -->
  <div id="intel-panel" class="panel">
    <div class="intel-header">
      <div class="intel-title">
        <span>üîî</span> Threat Intelligence
      </div>
      <div class="intel-subtitle">Real-time CVE monitoring and security advisories</div>
    </div>

    <div class="intel-search">
      <input type="text" id="cveSearch" placeholder="Search CVE (e.g., CVE-2021-44228) or package (e.g., log4j)">
      <button onclick="searchCVE()">Search</button>
    </div>

    <div id="cveSearchResults" style="display: none;">
      <!-- Search results populated by JS -->
    </div>

    <div class="trending-header">üî• Trending Vulnerabilities</div>
    <div class="cve-list" id="trendingCVEs">
      <div style="text-align: center; color: var(--text-muted); padding: 20px;">
        Loading trending CVEs...
      </div>
    </div>

    <div class="trending-header" style="margin-top: 32px;">üì¶ Package Advisories</div>
    <div class="cve-list" id="packageAdvisories">
      <div style="text-align: center; color: var(--text-muted); padding: 20px;">
        Enter a package name above to check for advisories
      </div>
    </div>
  </div>

  <!-- Attack Paths Panel -->
  <div id="attack-panel" class="panel">
    <div class="attack-header">
      <div class="attack-title">
        <span>‚öîÔ∏è</span> Attack Path Analysis
      </div>
      <div class="attack-subtitle">Trace exploitation chains through your vulnerabilities</div>
    </div>

    <div style="margin-bottom: 20px;">
      <button class="attack-btn primary" onclick="analyzeAttackPaths()" id="analyzeAttackBtn">
        üîç Analyze Attack Paths from Last Scan
      </button>
      <span id="attackStatus" style="margin-left: 12px; color: var(--text-secondary); font-size: 13px;"></span>
    </div>

    <div id="attackPathsContainer">
      <div style="text-align: center; color: var(--text-muted); padding: 40px;">
        Run a scan first, then analyze attack paths to see exploitation chains
      </div>
    </div>

    <div class="trending-header" style="margin-top: 32px;">üéØ MITRE ATT&CK Coverage</div>
    <div id="mitreMatrix" style="margin-top: 12px;">
      <div style="text-align: center; color: var(--text-muted); padding: 20px;">
        MITRE mapping will appear after attack path analysis
      </div>
    </div>
  </div>

  <!-- View Info -->
  <div id="view-info" class="panel">
    <kbd>Drag</kbd> Rotate &nbsp; <kbd>Scroll</kbd> Zoom &nbsp; <kbd>Click</kbd> Select node
  </div>

  <!-- Scripts -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ========== STATE ==========
    const state = {
      repos: [],
      selectedRepo: null,
      reports: [],
      currentView: 'scan',
      drillLevel: 0,        // 0=repos, 1=severities, 2=findings
      selectedSeverity: null, // 'critical', 'high', 'medium', 'low'
      attackPaths: []       // Cached attack paths for simulate/report
    };

    // Auto-detect API URL: localhost uses port 3000, production uses nginx proxy (same origin)
    const isLocal = window.location.hostname === '127.0.0.1' || window.location.hostname === 'localhost';
    const AURA_URL = isLocal
      ? 'http://127.0.0.1:3000'
      : window.location.origin;  // nginx proxies /tools, /info, /score, etc. to port 3000

    // ========== THREE.JS SETUP ==========
    let scene, camera, renderer, controls;
    let repoNodes = [];
    let centralNode;
    let raycaster, mouse;
    let findingNodes = [];  // 3D nodes for vulnerabilities/secrets
    let findingLines = [];  // Connection lines for findings
    let hoveredNode = null; // Currently hovered repo node

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0d1117);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 25, 45);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI / 2.1;
      controls.minDistance = 15;
      controls.maxDistance = 80;

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Lights
      const ambientLight = new THREE.AmbientLight(0x404040, 1);
      scene.add(ambientLight);

      const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
      mainLight.position.set(10, 20, 10);
      scene.add(mainLight);

      const fillLight = new THREE.DirectionalLight(0x58a6ff, 0.3);
      fillLight.position.set(-10, 10, -10);
      scene.add(fillLight);

      createGrid();
      createCentralHub();

      window.addEventListener('resize', onResize);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);

      animate();
    }

    function createGrid() {
      const gridHelper = new THREE.GridHelper(60, 30, 0x30363d, 0x21262d);
      scene.add(gridHelper);
    }

    function createCentralHub() {
      const group = new THREE.Group();

      // Core sphere
      const coreGeom = new THREE.IcosahedronGeometry(2.5, 1);
      const coreMat = new THREE.MeshPhongMaterial({
        color: 0x58a6ff,
        emissive: 0x58a6ff,
        emissiveIntensity: 0.2,
        flatShading: true
      });
      const core = new THREE.Mesh(coreGeom, coreMat);
      group.add(core);

      // Outer ring
      const ringGeom = new THREE.TorusGeometry(4, 0.15, 8, 32);
      const ringMat = new THREE.MeshBasicMaterial({
        color: 0x58a6ff,
        transparent: true,
        opacity: 0.4
      });
      const ring = new THREE.Mesh(ringGeom, ringMat);
      ring.rotation.x = Math.PI / 2;
      group.add(ring);

      group.position.y = 4;
      centralNode = group;
      scene.add(group);
    }

    function addRepoNode(repo) {
      const existingNode = repoNodes.find(n => n.userData.repoId === repo.id);
      if (existingNode) {
        updateNodeColor(existingNode, repo);
        return existingNode;
      }

      const group = new THREE.Group();

      // Determine color based on threat level
      let color = 0x3fb950; // success/safe
      if (repo.secrets > 0 || repo.vulns > 10) color = 0xf85149; // critical
      else if (repo.vulns > 0) color = 0xd29922; // warning

      // Base platform
      const baseGeom = new THREE.CylinderGeometry(1.8, 2, 0.3, 6);
      const baseMat = new THREE.MeshPhongMaterial({
        color: 0x21262d,
        flatShading: true
      });
      const base = new THREE.Mesh(baseGeom, baseMat);
      group.add(base);

      // Main block
      const blockGeom = new THREE.BoxGeometry(2, 2.5, 2);
      const blockMat = new THREE.MeshPhongMaterial({
        color: color,
        flatShading: true
      });
      const block = new THREE.Mesh(blockGeom, blockMat);
      block.position.y = 1.5;
      group.add(block);

      // Top indicator
      const topGeom = new THREE.ConeGeometry(0.5, 0.8, 4);
      const topMat = new THREE.MeshPhongMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.3
      });
      const top = new THREE.Mesh(topGeom, topMat);
      top.position.y = 3.2;
      group.add(top);

      // Position in circle
      const angle = (repoNodes.length / 8) * Math.PI * 2;
      const radius = 12 + Math.floor(repoNodes.length / 8) * 7;
      group.position.set(
        Math.cos(angle) * radius,
        0,
        Math.sin(angle) * radius
      );

      group.userData = {
        repoId: repo.id,
        repoName: repo.name,
        color: color
      };

      // Connection line
      const lineGeom = new THREE.BufferGeometry().setFromPoints([
        group.position.clone().add(new THREE.Vector3(0, 1.5, 0)),
        centralNode.position.clone()
      ]);
      const lineMat = new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.3
      });
      const line = new THREE.Line(lineGeom, lineMat);
      scene.add(line);
      group.userData.connectionLine = line;

      repoNodes.push(group);
      scene.add(group);

      return group;
    }

    function updateNodeColor(node, repo) {
      let color = 0x3fb950;
      if (repo.secrets > 0 || repo.vulns > 10) color = 0xf85149;
      else if (repo.vulns > 0) color = 0xd29922;

      node.children.forEach((child, i) => {
        if (i > 0 && child.material) {
          child.material.color.setHex(color);
          if (child.material.emissive) child.material.emissive.setHex(color);
        }
      });

      if (node.userData.connectionLine) {
        node.userData.connectionLine.material.color.setHex(color);
      }

      node.userData.color = color;
    }

    // Severity colors and labels
    const SEVERITY_CONFIG = {
      critical: { color: 0xf85149, label: 'Critical', icon: 'octahedron' },
      high: { color: 0xdb6d28, label: 'High', icon: 'box' },
      medium: { color: 0xd29922, label: 'Medium', icon: 'sphere' },
      low: { color: 0x58a6ff, label: 'Low', icon: 'cone' }
    };

    // Clear all finding nodes from the scene
    function clearFindingNodes() {
      findingNodes.forEach(node => {
        scene.remove(node);
        if (node.geometry) node.geometry.dispose();
        if (node.material) node.material.dispose();
      });
      findingNodes = [];

      findingLines.forEach(line => {
        scene.remove(line);
        if (line.geometry) line.geometry.dispose();
        if (line.material) line.material.dispose();
      });
      findingLines = [];
    }

    // Update navigation breadcrumb
    function updateNav3D() {
      const nav = document.getElementById('nav3d');
      const repoName = document.querySelector('#nav3d .nav-repo');
      const sevSep = document.querySelector('#nav3d .nav-sev-sep');
      const sevName = document.querySelector('#nav3d .nav-severity');

      if (state.drillLevel === 0) {
        nav.classList.remove('visible');
      } else {
        nav.classList.add('visible');
        const repo = state.repos.find(r => r.id === state.selectedRepo);
        repoName.textContent = repo?.name || '';
        repoName.classList.toggle('active', state.drillLevel === 1);

        if (state.drillLevel === 2 && state.selectedSeverity) {
          sevSep.style.display = 'inline';
          sevName.style.display = 'inline';
          sevName.textContent = SEVERITY_CONFIG[state.selectedSeverity]?.label || state.selectedSeverity;
          sevName.classList.add('active');
          repoName.classList.remove('active');
        } else {
          sevSep.style.display = 'none';
          sevName.style.display = 'none';
        }
      }
    }

    // Navigate back one level
    function navigateBack() {
      if (state.drillLevel === 2) {
        // Go back to severity view
        state.drillLevel = 1;
        state.selectedSeverity = null;
        const repo = state.repos.find(r => r.id === state.selectedRepo);
        const repoNode = repoNodes.find(n => n.userData.repoId === state.selectedRepo);
        if (repo && repoNode) {
          showSeverityNodes(repo, repoNode);
        }
      } else if (state.drillLevel === 1) {
        // Go back to repo view
        state.drillLevel = 0;
        state.selectedRepo = null;
        clearFindingNodes();
        document.getElementById('selectedRepoInfo').classList.remove('visible');
        repoNodes.forEach(node => node.scale.setScalar(1));
      }
      updateNav3D();
    }
    window.navigateBack = navigateBack;

    // Navigate to specific level
    function navigateToLevel(level) {
      if (level === 0) {
        state.drillLevel = 0;
        state.selectedRepo = null;
        state.selectedSeverity = null;
        clearFindingNodes();
        document.getElementById('selectedRepoInfo').classList.remove('visible');
        repoNodes.forEach(node => node.scale.setScalar(1));
      } else if (level === 1 && state.selectedRepo) {
        state.drillLevel = 1;
        state.selectedSeverity = null;
        const repo = state.repos.find(r => r.id === state.selectedRepo);
        const repoNode = repoNodes.find(n => n.userData.repoId === state.selectedRepo);
        if (repo && repoNode) {
          showSeverityNodes(repo, repoNode);
        }
      }
      updateNav3D();
    }
    window.navigateToLevel = navigateToLevel;

    // LEVEL 1: Show severity category nodes around a repo
    function showSeverityNodes(repo, repoNode) {
      clearFindingNodes();
      state.drillLevel = 1;
      updateNav3D();

      if (!repo.findings || repo.findings.length === 0) return;

      const repoPos = repoNode.position.clone();
      repoPos.y += 2;

      // Count findings by severity
      const counts = { critical: 0, high: 0, medium: 0, low: 0 };
      repo.findings.forEach(f => {
        const sev = f.type === 'SECRET' ? 'critical' : (f.severity?.toLowerCase() || 'medium');
        if (counts[sev] !== undefined) counts[sev]++;
        else counts.medium++;
      });

      // Filter to only severities with findings
      const severities = ['critical', 'high', 'medium', 'low'];
      const activeSeverities = severities.filter(sev => counts[sev] > 0);
      const radius = 6;

      // Position nodes evenly based on how many we actually have
      activeSeverities.forEach((sev, i) => {
        const count = counts[sev];
        const config = SEVERITY_CONFIG[sev];
        // Distribute evenly around the circle based on active count
        const angle = (i / activeSeverities.length) * Math.PI * 2 - Math.PI / 2;

        // Create severity node based on icon type
        let geom;
        const size = 0.8 + Math.min(count / 10, 1) * 0.5; // Scale by count
        switch (config.icon) {
          case 'octahedron':
            geom = new THREE.OctahedronGeometry(size, 0);
            break;
          case 'box':
            geom = new THREE.BoxGeometry(size * 1.5, size * 1.5, size * 1.5);
            break;
          case 'cone':
            geom = new THREE.ConeGeometry(size, size * 1.5, 6);
            break;
          default:
            geom = new THREE.SphereGeometry(size, 12, 12);
        }

        const mat = new THREE.MeshPhongMaterial({
          color: config.color,
          emissive: config.color,
          emissiveIntensity: 0.3,
          flatShading: true
        });

        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(
          repoPos.x + Math.cos(angle) * radius,
          repoPos.y + 2,
          repoPos.z + Math.sin(angle) * radius
        );

        mesh.userData = {
          isSeverityNode: true,
          severity: sev,
          count: count,
          label: `${config.label} (${count})`
        };

        scene.add(mesh);
        findingNodes.push(mesh);

        // Create connection line
        const lineGeom = new THREE.BufferGeometry().setFromPoints([
          mesh.position.clone(),
          repoPos.clone().add(new THREE.Vector3(0, 1, 0))
        ]);
        const lineMat = new THREE.LineBasicMaterial({
          color: config.color,
          transparent: true,
          opacity: 0.6
        });
        const line = new THREE.Line(lineGeom, lineMat);
        scene.add(line);
        findingLines.push(line);

        // Add count label as sprite
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#' + config.color.toString(16).padStart(6, '0');
        ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(count.toString(), 64, 40);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.position.copy(mesh.position);
        sprite.position.y += 1.5;
        sprite.scale.set(2, 1, 1);
        scene.add(sprite);
        findingNodes.push(sprite);
      });
    }

    // LEVEL 2: Show individual findings for a severity
    function showFindingsForSeverity(repo, repoNode, severity) {
      clearFindingNodes();
      state.drillLevel = 2;
      state.selectedSeverity = severity;
      updateNav3D();

      const repoPos = repoNode.position.clone();
      repoPos.y += 2;

      // Filter findings by severity
      const findings = repo.findings.filter(f => {
        const fSev = f.type === 'SECRET' ? 'critical' : (f.severity?.toLowerCase() || 'medium');
        return fSev === severity;
      }).slice(0, 25); // Limit for performance

      const config = SEVERITY_CONFIG[severity];
      const radius = 5;

      findings.forEach((finding, i) => {
        const angle = (i / findings.length) * Math.PI * 2;
        const yOffset = Math.sin(i * 0.5) * 2;

        // Create finding node
        const size = 0.35;
        const geom = finding.type === 'SECRET'
          ? new THREE.OctahedronGeometry(size, 0)
          : new THREE.SphereGeometry(size, 8, 8);
        const mat = new THREE.MeshPhongMaterial({
          color: config.color,
          emissive: config.color,
          emissiveIntensity: 0.5,
          flatShading: true
        });

        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(
          repoPos.x + Math.cos(angle) * radius,
          repoPos.y + yOffset + 2,
          repoPos.z + Math.sin(angle) * radius
        );

        mesh.userData = {
          isFindingNode: true,
          finding: finding
        };

        scene.add(mesh);
        findingNodes.push(mesh);

        // Create connection line
        const lineGeom = new THREE.BufferGeometry().setFromPoints([
          mesh.position.clone(),
          repoPos.clone().add(new THREE.Vector3(0, 1.5, 0))
        ]);
        const lineMat = new THREE.LineBasicMaterial({
          color: config.color,
          transparent: true,
          opacity: 0.4
        });
        const line = new THREE.Line(lineGeom, lineMat);
        scene.add(line);
        findingLines.push(line);
      });

      // Create central severity indicator
      const centralGeom = new THREE.TorusGeometry(2, 0.2, 8, 24);
      const centralMat = new THREE.MeshPhongMaterial({
        color: config.color,
        emissive: config.color,
        emissiveIntensity: 0.3
      });
      const centralRing = new THREE.Mesh(centralGeom, centralMat);
      centralRing.position.copy(repoPos);
      centralRing.position.y += 2;
      centralRing.rotation.x = Math.PI / 2;
      scene.add(centralRing);
      findingNodes.push(centralRing);
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // Gentle rotation of central hub
      if (centralNode) {
        centralNode.children[0].rotation.y += 0.003;
        centralNode.children[1].rotation.z += 0.005;
      }

      // Subtle float for repo nodes
      repoNodes.forEach((node, i) => {
        node.position.y = Math.sin(time * 0.5 + i) * 0.15;
      });

      // Animate finding nodes - gentle orbit and pulse
      findingNodes.forEach((node, i) => {
        node.rotation.y += 0.02;
        node.rotation.x += 0.01;
        // Pulse effect
        const scale = 1 + Math.sin(time * 3 + i) * 0.1;
        node.scale.setScalar(scale);
      });

      controls.update();
      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      // Check for intersections with finding nodes first, then repo nodes
      const allClickables = [...findingNodes.filter(n => n.userData.isSeverityNode || n.userData.isFindingNode), ...repoNodes];
      const intersects = raycaster.intersectObjects(allClickables, true);

      const tooltip = document.getElementById('tooltip3d');

      if (intersects.length > 0) {
        document.body.style.cursor = 'pointer';
        let target = intersects[0].object;

        // Check if it's a severity node
        if (target.userData.isSeverityNode) {
          tooltip.querySelector('.tooltip-name').textContent = target.userData.label;
          tooltip.querySelector('.tooltip-stats').innerHTML = `
            <span class="tooltip-stat">Click to view findings</span>
          `;
          tooltip.querySelector('.tooltip-hint').textContent = 'Drill down into ' + target.userData.label;
          tooltip.style.left = (event.clientX + 15) + 'px';
          tooltip.style.top = (event.clientY + 15) + 'px';
          tooltip.classList.add('visible');
          return;
        }

        // Check if it's a finding node
        if (target.userData.isFindingNode) {
          const f = target.userData.finding;
          tooltip.querySelector('.tooltip-name').textContent = f.message || f.type;
          tooltip.querySelector('.tooltip-stats').innerHTML = `
            <span class="tooltip-stat">${f.type}</span>
          `;
          tooltip.querySelector('.tooltip-hint').textContent = f.file ? f.file + (f.line ? ':' + f.line : '') : '';
          tooltip.style.left = (event.clientX + 15) + 'px';
          tooltip.style.top = (event.clientY + 15) + 'px';
          tooltip.classList.add('visible');
          return;
        }

        // Find the repo node group
        while (target.parent && !target.userData.repoId) {
          target = target.parent;
        }

        if (target.userData.repoId && target !== hoveredNode) {
          hoveredNode = target;
          const repo = state.repos.find(r => r.id === target.userData.repoId);

          if (repo) {
            // Update tooltip content
            tooltip.querySelector('.tooltip-name').textContent = repo.name;
            tooltip.querySelector('.tooltip-stats').innerHTML = `
              <span class="tooltip-stat critical"><span class="count">${repo.secrets}</span> Secrets</span>
              <span class="tooltip-stat warning"><span class="count">${repo.vulns}</span> Vulns</span>
            `;
            tooltip.querySelector('.tooltip-hint').textContent = 'Click to view severity breakdown';

            // Update colors based on status
            const critStat = tooltip.querySelector('.tooltip-stat.critical');
            const warnStat = tooltip.querySelector('.tooltip-stat.warning');
            if (critStat) critStat.style.color = repo.secrets > 0 ? 'var(--critical)' : 'var(--text-muted)';
            if (warnStat) warnStat.style.color = repo.vulns > 0 ? 'var(--warning)' : 'var(--text-muted)';
          }
        }

        // Position tooltip near cursor
        tooltip.style.left = (event.clientX + 15) + 'px';
        tooltip.style.top = (event.clientY + 15) + 'px';
        tooltip.classList.add('visible');

      } else {
        document.body.style.cursor = 'default';
        tooltip.classList.remove('visible');
        hoveredNode = null;
      }
    }

    function onMouseClick(event) {
      raycaster.setFromCamera(mouse, camera);

      // Check for intersections with finding nodes first, then repo nodes
      const allClickables = [...findingNodes.filter(n => n.userData.isSeverityNode), ...repoNodes];
      const intersects = raycaster.intersectObjects(allClickables, true);

      console.log('[Click] Intersects:', intersects.length, 'allClickables:', allClickables.length);

      if (intersects.length > 0) {
        let target = intersects[0].object;
        console.log('[Click] Target object:', target.userData);

        // Check if clicking a severity node (drill down to findings)
        if (target.userData.isSeverityNode) {
          console.log('[Click] Clicking severity node:', target.userData.severity);
          const repo = state.repos.find(r => r.id === state.selectedRepo);
          const repoNode = repoNodes.find(n => n.userData.repoId === state.selectedRepo);
          if (repo && repoNode) {
            showFindingsForSeverity(repo, repoNode, target.userData.severity);
          }
          return;
        }

        // Otherwise, find the repo node group
        while (target.parent && !target.userData.repoId) {
          target = target.parent;
        }
        if (target.userData.repoId) {
          console.log('[Click] Clicking repo node:', target.userData.repoId, target.userData.repoName);
          selectRepo(target.userData.repoId);
        }
      }
    }

    // ========== UI FUNCTIONS ==========
    function showView(view) {
      state.currentView = view;
      document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
      event.target.classList.add('active');

      document.getElementById('scanner-panel').style.display = view === 'scan' ? 'block' : 'none';
      document.getElementById('details-panel').style.display = view === 'scan' ? 'block' : 'none';
      document.getElementById('reports-panel').classList.toggle('active', view === 'reports');
      document.getElementById('rugcheck-panel').classList.toggle('active', view === 'rugcheck');
      document.getElementById('intel-panel').classList.toggle('active', view === 'intel');
      document.getElementById('attack-panel').classList.toggle('active', view === 'attack');
      document.getElementById('view-info').style.display = view === 'scan' ? 'block' : 'none';

      if (view === 'reports') updateReportsTable();
      if (view === 'intel') loadTrendingCVEs();
      if (view === 'attack') checkAttackPathsReady();
    }
    window.showView = showView;

    function log(message, type = 'info') {
      const output = document.getElementById('logOutput');
      const line = document.createElement('div');
      line.className = `log-line ${type}`;
      line.textContent = message;
      output.appendChild(line);
      output.scrollTop = output.scrollHeight;
    }

    async function executeScan() {
      const localPath = document.getElementById('scanPath').value.trim();
      const gitUrl = document.getElementById('gitUrl').value.trim();

      if (!localPath && !gitUrl) {
        log('Error: No target specified', 'error');
        return;
      }

      const scanBtn = document.getElementById('scanBtn');
      scanBtn.disabled = true;
      scanBtn.textContent = 'Scanning...';

      const args = { scanSecrets: true, scanPackages: true };
      let targetName = '';
      let targetType = '';

      if (gitUrl) {
        args.gitUrl = gitUrl;
        targetName = gitUrl.split('/').slice(-2).join('/').replace('.git', '');
        targetType = 'git';
        log(`Scanning: ${gitUrl}`);
      } else {
        args.targetPath = localPath;
        targetName = localPath.split(/[/\\]/).pop() || localPath;
        targetType = 'local';
        log(`Scanning: ${localPath}`);
      }

      try {
        const res = await fetch(`${AURA_URL}/tools`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tool: 'scan-local', arguments: args })
        });

        // Check if response is OK before parsing JSON
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`Server error (${res.status}): ${errorText.substring(0, 100)}`);
        }

        // Safely parse JSON
        let data;
        try {
          data = await res.json();
        } catch (parseErr) {
          throw new Error('Invalid response from server (not JSON)');
        }
        console.log('API Response:', JSON.stringify(data, null, 2));

        if (data.result?.error) {
          throw new Error(data.result.error);
        }

        const scanData = data.result?.scan_details || data.result || data;
        console.log('scanData:', JSON.stringify({
          secrets_found: scanData.secrets_found,
          package_vulns: scanData.package_vulns,
          raw_findings_keys: Object.keys(scanData.raw_findings || {})
        }, null, 2));
        const repoPath = gitUrl || localPath;

        // Check if this repo was already scanned (update instead of duplicate)
        const existingRepo = state.repos.find(r => r.path === repoPath);
        const existingReportIdx = state.reports.findIndex(r => r.path === repoPath);

        const repo = {
          id: existingRepo?.id || Date.now().toString(),
          name: targetName,
          path: repoPath,
          type: targetType,
          secrets: scanData.secrets_found || 0,
          vulns: scanData.package_vulns || 0,
          findings: [],
          timestamp: new Date().toISOString(),
          status: 'complete',
          rawData: scanData
        };

        // Extract findings from all sources
        const rf = scanData.raw_findings || {};

        // Secrets - use actual severity from scanner
        if (rf.secrets) {
          rf.secrets.forEach(s => {
            repo.findings.push({
              severity: s.severity?.toLowerCase() || 'critical',
              type: 'SECRET',
              message: `${s.type || 'Secret'} detected`,
              file: s.file,
              line: s.line
            });
          });
        }

        // Package vulnerabilities (backend uses 'packages' not 'packageVulns')
        if (rf.packages) {
          rf.packages.forEach(v => {
            repo.findings.push({
              severity: v.severity?.toLowerCase() || 'medium',
              type: 'VULN',
              message: v.title || v.vulnId || v.name,
              file: `${v.name}@${v.version}`
            });
          });
        }

        // SAST findings
        if (rf.sastFindings) {
          rf.sastFindings.forEach(s => {
            repo.findings.push({
              severity: s.severity?.toLowerCase() || 'medium',
              type: 'CODE',
              message: s.message || s.rule,
              file: s.file,
              line: s.line
            });
          });
        }

        // IaC findings (Terraform, Kubernetes, etc.)
        if (rf.iacFindings) {
          rf.iacFindings.forEach(i => {
            repo.findings.push({
              severity: i.severity?.toLowerCase() || 'medium',
              type: 'IAC',
              message: i.title || i.checkId,
              file: i.file
            });
          });
        }

        // Dockerfile findings
        if (rf.dockerfileFindings) {
          rf.dockerfileFindings.forEach(d => {
            repo.findings.push({
              severity: d.severity?.toLowerCase() || 'medium',
              type: 'DOCKER',
              message: d.message || d.code,
              file: d.file,
              line: d.line
            });
          });
        }

        // Update or add repo to state
        if (existingRepo) {
          // Update existing repo
          const idx = state.repos.findIndex(r => r.id === existingRepo.id);
          if (idx !== -1) state.repos[idx] = repo;

          // Update existing report
          if (existingReportIdx !== -1) state.reports[existingReportIdx] = repo;

          // Update existing 3D node
          const existingNode = repoNodes.find(n => n.userData.repoId === repo.id);
          if (existingNode) {
            updateNodeColor(existingNode, repo);
          }

          log(`Updated: ${repo.secrets} secrets, ${repo.vulns} vulnerabilities`, repo.secrets > 0 ? 'error' : 'success');
        } else {
          // Add new repo
          state.repos.push(repo);
          state.reports.push(repo);
          addRepoNode(repo);

          log(`Complete: ${repo.secrets} secrets, ${repo.vulns} vulnerabilities`, repo.secrets > 0 ? 'error' : 'success');
        }
        // Clear attack paths when new scan completes (force fresh analysis)
        state.attackPaths = [];

        updateUI();
        refreshScore(); // Update security score after scan
        selectRepo(repo.id);

      } catch (err) {
        console.error('Scan error:', err);
        log(`Error: ${err.message}`, 'error');
      }

      scanBtn.disabled = false;
      scanBtn.textContent = 'Start Scan';
    }
    window.executeScan = executeScan;

    function selectRepo(repoId) {
      console.log('[SelectRepo] Called with repoId:', repoId);
      state.selectedRepo = repoId;
      updateUI();

      let selectedNode = null;
      repoNodes.forEach(node => {
        const isSelected = node.userData.repoId === repoId;
        node.scale.setScalar(isSelected ? 1.15 : 1);
        if (isSelected) selectedNode = node;
      });

      document.querySelectorAll('.repo-item').forEach(item => {
        item.classList.toggle('selected', item.dataset.id === repoId);
      });

      const repo = state.repos.find(r => r.id === repoId);
      console.log('[SelectRepo] Found repo:', repo?.name, 'secrets:', repo?.secrets, 'vulns:', repo?.vulns, 'findings:', repo?.findings?.length);

      // Update Attack Paths tab when repo changes
      if (state.currentView === 'attack') {
        checkAttackPathsReady();
      }

      if (repo) {
        document.getElementById('selectedRepoInfo').classList.add('visible');
        document.getElementById('selectedRepoName').textContent = repo.name;
        document.getElementById('selectedRepoPath').textContent = repo.path;
        updateFindingsList(repo);

        // Update score display for this specific repo
        updateScoreForRepo(repo);

        // Show severity breakdown in 3D view (Level 1)
        if (selectedNode) {
          showSeverityNodes(repo, selectedNode);
        }
      } else {
        // No repo selected, clear finding nodes
        state.drillLevel = 0;
        clearFindingNodes();
        updateNav3D();
      }
    }
    window.selectRepo = selectRepo;

    // ========== FILTER TOGGLES ==========
    const filters = {
      severity: { critical: true, high: true, medium: true, low: true },
      type: { SECRET: true, VULN: true, CODE: true, IAC: true, DOCKER: true }
    };

    function toggleFilter(category, value) {
      filters[category][value] = !filters[category][value];

      // Update button state
      const btn = document.querySelector(`.filter-toggle[data-filter="${value}"]`);
      if (btn) {
        btn.classList.toggle('active', filters[category][value]);
      }

      // Re-render findings list with filters
      if (state.selectedRepo) {
        const repo = state.repos.find(r => r.id === state.selectedRepo);
        if (repo) {
          updateFindingsList(repo);
        }
      }
    }
    window.toggleFilter = toggleFilter;

    function updateFilterCounts(repo) {
      const counts = { critical: 0, high: 0, medium: 0, low: 0 };
      if (repo && repo.findings) {
        repo.findings.forEach(f => {
          const sev = f.severity?.toLowerCase() || 'medium';
          if (counts[sev] !== undefined) counts[sev]++;
        });
      }

      document.getElementById('countCritical').textContent = counts.critical;
      document.getElementById('countHigh').textContent = counts.high;
      document.getElementById('countMedium').textContent = counts.medium;
      document.getElementById('countLow').textContent = counts.low;
    }

    // ========== BADGE GENERATOR ==========
    function generateBadge(repo) {
      if (!repo) return;

      const secrets = repo.secrets || 0;
      const vulns = repo.vulns || 0;

      // Determine status and color
      let status, color;
      if (secrets > 0) {
        status = `${secrets} secrets`;
        color = 'critical';
      } else if (vulns > 10) {
        status = `${vulns} vulns`;
        color = 'important';
      } else if (vulns > 0) {
        status = `${vulns} vulns`;
        color = 'yellow';
      } else {
        status = 'passing';
        color = 'success';
      }

      // Generate shields.io URL
      const label = 'security';
      const encodedStatus = encodeURIComponent(status);
      const badgeUrl = `https://img.shields.io/badge/${label}-${encodedStatus}-${color}?style=flat-square&logo=shield&logoColor=white`;

      // Update preview
      const badgeImg = document.getElementById('badgeImg');
      badgeImg.src = badgeUrl;
      badgeImg.alt = `Security: ${status}`;

      // Store for copy functions
      window.currentBadge = {
        url: badgeUrl,
        label: label,
        status: status,
        repoName: repo.name
      };

      // Update code preview with markdown
      const markdown = `[![Security](${badgeUrl})](https://aurasecurity.io)`;
      document.getElementById('badgeCode').textContent = markdown;

      // Show badge section
      document.getElementById('badgeSection').style.display = 'block';
    }

    function copyBadge(format) {
      if (!window.currentBadge) return;

      let text;
      if (format === 'markdown') {
        text = `[![Security](${window.currentBadge.url})](https://aurasecurity.io)`;
      } else {
        text = `<a href="https://aurasecurity.io"><img src="${window.currentBadge.url}" alt="Security"></a>`;
      }

      navigator.clipboard.writeText(text).then(() => {
        const successEl = document.getElementById('copySuccess');
        successEl.classList.add('visible');
        setTimeout(() => successEl.classList.remove('visible'), 2000);
      });
    }
    window.copyBadge = copyBadge;

    function updateUI() {
      let totalCrit = 0, totalWarn = 0;
      state.repos.forEach(r => {
        totalCrit += r.secrets;
        totalWarn += r.vulns;
      });

      document.getElementById('totalCritical').textContent = totalCrit;
      document.getElementById('totalWarning').textContent = totalWarn;
      document.getElementById('totalRepos').textContent = state.repos.length;

      const repoList = document.getElementById('repoList');
      if (state.repos.length === 0) {
        repoList.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üìÅ</div>
            <p>No targets scanned yet</p>
          </div>
        `;
      } else {
        repoList.innerHTML = state.repos.map(r => {
          let status = 'safe';
          if (r.secrets > 0) status = 'critical';
          else if (r.vulns > 0) status = 'warning';

          return `
            <div class="repo-item ${state.selectedRepo === r.id ? 'selected' : ''}"
                 data-id="${r.id}" onclick="selectRepo('${r.id}')">
              <div class="repo-status ${status}"></div>
              <div class="repo-info">
                <div class="repo-name">${r.name}</div>
                <div class="repo-path">${r.type === 'git' ? 'üåê' : 'üìÅ'} ${r.path}</div>
              </div>
              <div class="repo-stats">${r.secrets}S / ${r.vulns}V</div>
            </div>
          `;
        }).join('');
      }
    }

    function updateFindingsList(repo) {
      const container = document.getElementById('findingList');

      // Show/hide filter section
      document.getElementById('filterSection').style.display = repo && repo.findings?.length > 0 ? 'block' : 'none';

      // Show/hide fixes section (show if repo has findings)
      showFixesSection(repo && repo.findings?.length > 0);
      // Reset fixes content when switching repos
      document.getElementById('fixesContent').innerHTML = '';
      currentFixesData = null;

      // Update filter counts
      updateFilterCounts(repo);

      // Generate badge
      generateBadge(repo);

      if (!repo || repo.findings.length === 0) {
        document.getElementById('badgeSection').style.display = 'none';
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">‚úì</div>
            <p>${repo ? 'No findings for this target' : 'Select a target to view findings'}</p>
          </div>
        `;
        return;
      }

      // Apply filters
      const filtered = repo.findings.filter(f => {
        const sev = f.severity?.toLowerCase() || 'medium';
        const type = f.type || 'CODE';
        return filters.severity[sev] && filters.type[type];
      });

      if (filtered.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üîç</div>
            <p>No findings match current filters</p>
          </div>
        `;
        return;
      }

      container.innerHTML = filtered.map(f => `
        <div class="finding-item ${f.severity}">
          <div class="finding-header">
            <span class="finding-severity">${f.severity}</span>
            <span class="finding-type">${f.type}</span>
          </div>
          <div class="finding-message">${f.message}</div>
          ${f.file ? `<div class="finding-file">${f.file}${f.line ? ':' + f.line : ''}</div>` : ''}
        </div>
      `).join('');
    }

    function updateReportsTable() {
      const tbody = document.getElementById('reportTableBody');

      if (state.reports.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: var(--text-muted);">No reports yet</td></tr>';
        return;
      }

      tbody.innerHTML = state.reports.map(r => `
        <tr>
          <td>${new Date(r.timestamp).toLocaleString()}</td>
          <td>${r.name}</td>
          <td>${r.type.toUpperCase()}</td>
          <td style="color: ${r.secrets > 0 ? 'var(--critical)' : 'var(--success)'}">${r.secrets}</td>
          <td style="color: ${r.vulns > 0 ? 'var(--warning)' : 'var(--success)'}">${r.vulns}</td>
          <td>${r.status}</td>
          <td>
            <button class="btn btn-secondary" style="width: auto; padding: 4px 10px; font-size: 11px;" onclick="viewReport('${r.id}')">View</button>
          </td>
        </tr>
      `).join('');
    }

    function viewReport(repoId) {
      showView('scan');
      document.querySelector('.nav-tab').classList.add('active');
      document.querySelectorAll('.nav-tab')[1].classList.remove('active');
      selectRepo(repoId);
    }
    window.viewReport = viewReport;

    function exportReports(format) {
      if (state.reports.length === 0) {
        log('No reports to export', 'error');
        return;
      }

      let content, filename, type;

      if (format === 'json') {
        content = JSON.stringify(state.reports, null, 2);
        filename = `aura-audit-${Date.now()}.json`;
        type = 'application/json';
      } else {
        const headers = ['Timestamp', 'Name', 'Path', 'Type', 'Secrets', 'Vulns', 'Status'];
        const rows = state.reports.map(r =>
          [r.timestamp, r.name, r.path, r.type, r.secrets, r.vulns, r.status].join(',')
        );
        content = [headers.join(','), ...rows].join('\n');
        filename = `aura-audit-${Date.now()}.csv`;
        type = 'text/csv';
      }

      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);

      log(`Exported ${state.reports.length} reports`, 'success');
    }
    window.exportReports = exportReports;

    function clearAllReports() {
      if (confirm('Clear all scan reports?')) {
        state.reports = [];
        state.repos = [];
        state.selectedRepo = null;

        repoNodes.forEach(node => {
          if (node.userData.connectionLine) scene.remove(node.userData.connectionLine);
          scene.remove(node);
        });
        repoNodes = [];

        updateUI();
        updateReportsTable();
        document.getElementById('selectedRepoInfo').classList.remove('visible');
        document.getElementById('findingList').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üîç</div>
            <p>Select a target to view findings</p>
          </div>
        `;

        log('All reports cleared');
      }
    }
    window.clearAllReports = clearAllReports;

    // ========== SECURITY SCORE ==========
    function calculateScore(counts) {
      const penalties = {
        critical: (counts.critical || 0) * 15,
        high: (counts.high || 0) * 8,
        medium: (counts.medium || 0) * 3,
        low: (counts.low || 0) * 1
      };
      const totalPenalty = penalties.critical + penalties.high + penalties.medium + penalties.low;
      const score = Math.round(100 / (1 + totalPenalty / 100));

      let grade = 'F', gradeColor = '#f85149';
      if (score >= 90) { grade = 'A'; gradeColor = '#3fb950'; }
      else if (score >= 70) { grade = 'B'; gradeColor = '#58a6ff'; }
      else if (score >= 50) { grade = 'C'; gradeColor = '#d29922'; }

      return { score, grade, gradeColor, breakdown: { ...penalties, totalPenalty } };
    }

    function updateScoreForRepo(repo) {
      console.log('[Score] updateScoreForRepo called for:', repo?.name);

      if (!repo) {
        console.log('[Score] No repo, falling back to global score');
        refreshScore();
        return;
      }

      // Count findings by severity - handle both findings array and raw counts
      const counts = { critical: 0, high: 0, medium: 0, low: 0 };

      if (repo.findings && repo.findings.length > 0) {
        // Calculate from findings array
        repo.findings.forEach(f => {
          const sev = (f.severity || 'medium').toLowerCase();
          if (counts[sev] !== undefined) counts[sev]++;
        });
        console.log('[Score] Calculated from findings:', counts);
      } else {
        // Fallback: use secrets and vulns counts if no findings array
        // Secrets are typically critical, vulns are mixed but default to medium
        counts.critical = repo.secrets || 0;
        counts.medium = repo.vulns || 0;
        console.log('[Score] Calculated from secrets/vulns:', counts);
      }

      const scoreData = calculateScore(counts);
      console.log('[Score] Result:', scoreData.score, scoreData.grade);

      // Update display
      document.getElementById('scoreNumber').textContent = scoreData.score;

      const gradeEl = document.getElementById('scoreGrade');
      gradeEl.textContent = scoreData.grade;
      gradeEl.className = 'score-grade';
      if (scoreData.score >= 90) gradeEl.classList.add('grade-a');
      else if (scoreData.score >= 70) gradeEl.classList.add('grade-b');
      else if (scoreData.score >= 50) gradeEl.classList.add('grade-c');
      else gradeEl.classList.add('grade-f');

      // Update progress ring
      const circumference = 106.8;
      const offset = circumference - (scoreData.score / 100) * circumference;
      const progressEl = document.getElementById('scoreProgress');
      progressEl.style.strokeDashoffset = offset;
      progressEl.style.stroke = scoreData.gradeColor;

      // Update trend to show repo name
      const trendEl = document.getElementById('scoreTrend');
      trendEl.textContent = repo.name;
      trendEl.className = 'score-trend same';
    }

    async function fetchSecurityScore() {
      try {
        const res = await fetch(`${AURA_URL}/score`);
        if (!res.ok) return null;
        return await res.json();
      } catch (e) {
        console.log('Score fetch failed:', e);
        return null;
      }
    }

    function updateScoreDisplay(scoreData) {
      if (!scoreData) {
        document.getElementById('scoreNumber').textContent = '--';
        document.getElementById('scoreGrade').textContent = '-';
        document.getElementById('scoreTrend').textContent = '--';
        return;
      }

      const { score, grade, gradeColor, trend } = scoreData;

      // Update score number
      document.getElementById('scoreNumber').textContent = score;

      // Update grade with color
      const gradeEl = document.getElementById('scoreGrade');
      gradeEl.textContent = grade;
      gradeEl.className = 'score-grade';
      if (score >= 90) gradeEl.classList.add('grade-a');
      else if (score >= 70) gradeEl.classList.add('grade-b');
      else if (score >= 50) gradeEl.classList.add('grade-c');
      else gradeEl.classList.add('grade-f');

      // Update progress ring (circumference = 2 * PI * 17 = 106.8)
      const circumference = 106.8;
      const offset = circumference - (score / 100) * circumference;
      const progressEl = document.getElementById('scoreProgress');
      progressEl.style.strokeDashoffset = offset;
      progressEl.style.stroke = gradeColor || (score >= 70 ? 'var(--success)' : score >= 50 ? 'var(--warning)' : 'var(--critical)');

      // Update trend indicator
      const trendEl = document.getElementById('scoreTrend');
      if (trend && trend.previousScore !== null) {
        const arrow = trend.direction === 'up' ? '‚Üë' : trend.direction === 'down' ? '‚Üì' : '‚Üí';
        trendEl.textContent = `${arrow} ${trend.change}`;
        trendEl.className = `score-trend ${trend.direction}`;
      } else {
        trendEl.textContent = '‚Äî';
        trendEl.className = 'score-trend same';
      }

      // Update mini trend chart
      if (trend && trend.history && trend.history.length > 1) {
        const points = trend.history.slice().reverse();
        const maxScore = Math.max(...points.map(p => p.score), 100);
        const minScore = Math.min(...points.map(p => p.score), 0);
        const range = maxScore - minScore || 1;

        const polyPoints = points.map((p, i) => {
          const x = (i / (points.length - 1)) * 58 + 1;
          const y = 22 - ((p.score - minScore) / range) * 20;
          return `${x},${y}`;
        }).join(' ');

        document.getElementById('trendLine').setAttribute('points', polyPoints);
      }
    }

    async function refreshScore() {
      const scoreData = await fetchSecurityScore();
      updateScoreDisplay(scoreData);
    }

    // ========== INTEL AGENT INTEGRATION ==========
    // Intel Agent: localhost uses port 4008, production uses nginx proxy at /intel
    const INTEL_AGENT_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      ? 'http://localhost:4008'
      : `${window.location.origin}/intel`;

    async function loadTrendingCVEs() {
      const container = document.getElementById('trendingCVEs');
      try {
        const response = await fetch(`${INTEL_AGENT_URL}/tools`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tool: 'get-trending', arguments: { limit: 10 } })
        });
        const data = await response.json();
        const cves = data.result?.cves || data.result || [];

        if (cves.length === 0) {
          container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">No trending CVEs available</div>';
          return;
        }

        container.innerHTML = cves.map(cve => `
          <div class="cve-card">
            <div class="cve-card-header">
              <span class="cve-id">${cve.id || cve.cveId}</span>
              <span class="cve-cvss ${getCvssSeverity(cve.cvssScore || cve.cvss)}">${cve.cvssScore || cve.cvss || 'N/A'}</span>
            </div>
            <div class="cve-title">${cve.description || cve.title || 'No description'}</div>
            <div class="cve-meta">
              <span>Published: ${cve.published || 'Unknown'}</span>
              ${cve.exploitAvailable ? '<span style="color: var(--critical);">‚ö†Ô∏è Exploit Available</span>' : ''}
            </div>
          </div>
        `).join('');
      } catch (error) {
        container.innerHTML = `<div style="text-align: center; color: var(--critical); padding: 20px;">Error loading CVEs: ${error.message}</div>`;
      }
    }

    async function searchCVE() {
      const query = document.getElementById('cveSearch').value.trim();
      if (!query) return;

      const container = document.getElementById('cveSearchResults');
      container.style.display = 'block';
      container.innerHTML = '<div style="text-align: center; padding: 20px;">Searching...</div>';

      try {
        let response;
        if (query.toUpperCase().startsWith('CVE-')) {
          response = await fetch(`${INTEL_AGENT_URL}/tools`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tool: 'check-cve', arguments: { cveId: query.toUpperCase() } })
          });
        } else {
          response = await fetch(`${INTEL_AGENT_URL}/tools`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tool: 'check-package', arguments: { package: query } })
          });
        }

        const data = await response.json();
        const result = data.result;

        if (result.error || !result) {
          container.innerHTML = `<div style="text-align: center; padding: 20px; color: var(--text-muted);">No results found for "${query}"</div>`;
          return;
        }

        if (result.id || result.cveId) {
          // Single CVE result
          container.innerHTML = `
            <div class="cve-card" style="margin-bottom: 20px;">
              <div class="cve-card-header">
                <span class="cve-id">${result.id || result.cveId}</span>
                <span class="cve-cvss ${getCvssSeverity(result.cvssScore || result.cvss)}">${result.cvssScore || result.cvss || 'N/A'}</span>
              </div>
              <div class="cve-title">${result.description || result.title || 'No description'}</div>
              <div class="cve-meta">
                <span>Severity: ${result.severity || 'Unknown'}</span>
                ${result.exploitAvailable ? '<span style="color: var(--critical);">‚ö†Ô∏è Exploit Available</span>' : ''}
              </div>
            </div>
          `;
        } else if (result.vulnerabilities || result.advisories) {
          // Package vulnerabilities
          const vulns = result.vulnerabilities || result.advisories || [];
          container.innerHTML = `
            <div style="margin-bottom: 12px; font-weight: 600;">Found ${vulns.length} vulnerabilities for "${query}"</div>
            ${vulns.map(v => `
              <div class="cve-card">
                <div class="cve-card-header">
                  <span class="cve-id">${v.id || v.cveId || v.ghsaId || 'Unknown'}</span>
                  <span class="cve-cvss ${getCvssSeverity(v.cvssScore || v.severity)}">${v.cvssScore || v.severity || 'N/A'}</span>
                </div>
                <div class="cve-title">${v.summary || v.description || 'No description'}</div>
              </div>
            `).join('')}
          `;
        }
      } catch (error) {
        container.innerHTML = `<div style="text-align: center; color: var(--critical); padding: 20px;">Error: ${error.message}</div>`;
      }
    }
    window.searchCVE = searchCVE;

    function getCvssSeverity(score) {
      if (typeof score === 'string') {
        const s = score.toLowerCase();
        if (s === 'critical') return 'critical';
        if (s === 'high') return 'high';
        if (s === 'medium' || s === 'moderate') return 'medium';
        return 'low';
      }
      const n = parseFloat(score);
      if (n >= 9) return 'critical';
      if (n >= 7) return 'high';
      if (n >= 4) return 'medium';
      return 'low';
    }

    // ========== CHAIN MAPPER AGENT INTEGRATION ==========
    // Chain Mapper Agent: localhost uses port 4005, production uses nginx proxy at /chain
    const CHAIN_MAPPER_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      ? 'http://localhost:4005'
      : `${window.location.origin}/chain`;

    function checkAttackPathsReady() {
      const container = document.getElementById('attackPathsContainer');
      const btn = document.getElementById('analyzeAttackBtn');
      const status = document.getElementById('attackStatus');

      // Always get findings from the currently selected repo
      const repo = state.repos.find(r => r.id === state.selectedRepo);

      // Debug: Log all repos and their finding counts
      console.log('[AttackPaths] All repos:', state.repos.map(r => ({
        id: r.id,
        name: r.name,
        path: r.path,
        findings: r.findings?.length || 0
      })));
      console.log('[AttackPaths] Selected repo ID:', state.selectedRepo);
      console.log('[AttackPaths] Found repo:', repo?.name, 'with', repo?.findings?.length, 'findings');

      if (repo && repo.findings && repo.findings.length > 0) {
        const findingCount = repo.findings.length;
        // Count by type for breakdown
        const secretCount = repo.findings.filter(f => f.type === 'SECRET').length;
        const vulnCount = repo.findings.filter(f => f.type === 'VULN').length;
        const codeCount = repo.findings.filter(f => f.type === 'CODE').length;
        const iacCount = repo.findings.filter(f => f.type === 'IAC').length;
        const dockerCount = repo.findings.filter(f => f.type === 'DOCKER').length;

        btn.textContent = `üîç Analyze ${findingCount} Findings`;
        btn.disabled = false;

        // Build breakdown string
        const parts = [];
        if (secretCount > 0) parts.push(`${secretCount} secrets`);
        if (vulnCount > 0) parts.push(`${vulnCount} vulnerabilities`);
        if (codeCount > 0) parts.push(`${codeCount} code issues`);
        if (iacCount > 0) parts.push(`${iacCount} IaC issues`);
        if (dockerCount > 0) parts.push(`${dockerCount} Docker issues`);
        const breakdown = parts.length > 0 ? ` (${parts.join(', ')})` : '';

        status.textContent = `${repo.name || repo.path}: ${findingCount} findings${breakdown}`;
        // Clear previous results when switching repos
        container.innerHTML = `<div style="text-align: center; color: var(--text-secondary); padding: 40px;">
          Click "Analyze" to trace attack paths for <strong>${repo.name || repo.path}</strong><br><br>
          <span style="font-size: 24px; font-weight: 600;">${findingCount}</span> total findings<br>
          <span style="font-size: 12px; color: var(--text-muted);">${breakdown || 'No breakdown available'}</span>
        </div>`;
        state.attackPaths = []; // Clear cached paths
      } else if (state.repos.length > 0) {
        // No repo selected but repos exist - prompt user to select
        btn.textContent = 'üîç Select a Repository First';
        btn.disabled = true;
        status.textContent = 'Select a scanned repository from the sidebar';
        container.innerHTML = '<div style="text-align: center; color: var(--warning); padding: 40px;">Select a scanned repository from the sidebar to analyze attack paths.</div>';
      } else {
        btn.textContent = 'üîç Analyze Attack Paths (No Scan Data)';
        btn.disabled = true;
        status.textContent = 'No scan data available';
        container.innerHTML = '<div style="text-align: center; color: var(--warning); padding: 40px;">No findings to analyze. Run a scan first.</div>';
      }
    }

    async function analyzeAttackPaths() {
      const container = document.getElementById('attackPathsContainer');
      const status = document.getElementById('attackStatus');
      const mitreContainer = document.getElementById('mitreMatrix');

      // Get findings from currently selected repo only
      const repo = state.repos.find(r => r.id === state.selectedRepo);
      const findings = repo?.findings;

      console.log('[AttackPaths] Analyzing - repo:', repo?.name, 'findings count:', findings?.length);

      if (!findings || findings.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--warning); padding: 40px;">No findings to analyze. Select a scanned repository first.</div>';
        status.textContent = 'No findings available';
        return;
      }

      status.textContent = 'Analyzing attack paths...';
      container.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="loader"></div><br>Tracing exploitation chains...</div>';

      try {
        // Call Chain Mapper to trace paths
        const traceResponse = await fetch(`${CHAIN_MAPPER_URL}/tools`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tool: 'trace-path',
            arguments: { findings: findings, maxDepth: 5 }
          })
        });
        const traceData = await traceResponse.json();

        // Call for MITRE mapping
        const mitreResponse = await fetch(`${CHAIN_MAPPER_URL}/tools`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tool: 'map-mitre',
            arguments: { findings: findings }
          })
        });
        const mitreData = await mitreResponse.json();

        // Render attack paths
        const paths = traceData.result?.paths || traceData.result?.attackPaths || [];
        state.attackPaths = paths; // Store for simulate/report functions
        if (paths.length === 0) {
          container.innerHTML = '<div style="text-align: center; color: var(--success); padding: 40px;">‚úÖ No exploitable attack paths found</div>';
        } else {
          container.innerHTML = paths.map((path, i) => `
            <div class="attack-path-card">
              <div class="attack-path-header">
                <span class="attack-path-name">${path.name || `Attack Chain ${i + 1}`}</span>
                <span class="attack-path-risk ${(path.risk || path.severity || 'high').toLowerCase()}">${path.risk || path.severity || 'HIGH'}</span>
              </div>
              <div class="attack-path-steps">
                ${(path.steps || path.chain || []).map((step, j) => `
                  <div class="attack-step">
                    <span class="attack-step-num">${j + 1}</span>
                    <span class="attack-step-text">${step.description || step.action || step}</span>
                  </div>
                  ${j < (path.steps || path.chain || []).length - 1 ? '<div class="attack-step-arrow">‚Üì</div>' : ''}
                `).join('')}
              </div>
              ${path.mitreTechniques ? `
                <div class="mitre-tags">
                  ${path.mitreTechniques.map(t => `<span class="mitre-tag">${t}</span>`).join('')}
                </div>
              ` : ''}
              <div class="attack-actions">
                <button class="attack-btn" onclick="simulateAttack(${i})">üé≠ Simulate</button>
                <button class="attack-btn" onclick="generateReport(${i})">üìÑ Report</button>
              </div>
            </div>
          `).join('');
        }

        // Render MITRE matrix
        const mitreMappings = mitreData.result?.mappings || mitreData.result?.techniques || [];
        if (mitreMappings.length > 0) {
          const tactics = {};
          mitreMappings.forEach(m => {
            const tactic = m.tactic || 'Unknown';
            if (!tactics[tactic]) tactics[tactic] = [];
            tactics[tactic].push(m);
          });

          mitreContainer.innerHTML = `
            <div style="display: flex; flex-wrap: wrap; gap: 12px;">
              ${Object.entries(tactics).map(([tactic, techniques]) => `
                <div style="background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; padding: 12px; min-width: 150px;">
                  <div style="font-weight: 600; color: var(--accent); margin-bottom: 8px; font-size: 12px;">${tactic}</div>
                  ${techniques.map(t => `
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">
                      ${t.techniqueId || ''} ${t.name || t.technique || ''}
                    </div>
                  `).join('')}
                </div>
              `).join('')}
            </div>
          `;
        } else {
          mitreContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 13px;">No MITRE ATT&CK techniques mapped</div>';
        }

        status.textContent = `Found ${paths.length} attack path(s)`;

      } catch (error) {
        console.error('Attack path analysis error:', error);
        container.innerHTML = `<div style="text-align: center; color: var(--critical); padding: 40px;">Error: ${error.message}</div>`;
        status.textContent = 'Analysis failed';
      }
    }
    window.analyzeAttackPaths = analyzeAttackPaths;

    async function simulateAttack(pathIndex) {
      const path = state.attackPaths[pathIndex];
      if (!path) {
        alert('Attack path not found. Please re-run the analysis.');
        return;
      }

      // Create modal for simulation results
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 700px;">
          <div class="modal-header">
            <h3>üé≠ Attack Simulation: ${path.name || 'Attack Chain'}</h3>
            <button onclick="this.closest('.modal-overlay').remove()" style="background: none; border: none; color: var(--text-secondary); font-size: 24px; cursor: pointer;">&times;</button>
          </div>
          <div class="modal-body" id="simulationResults">
            <div style="text-align: center; padding: 40px;">
              <div class="loader"></div>
              <p style="margin-top: 16px; color: var(--text-secondary);">Running sandboxed simulation...</p>
              <p style="font-size: 12px; color: var(--text-muted);">Testing ${path.nodes?.length || 0} attack steps</p>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      try {
        // Extract findings from the path nodes
        const findings = (path.nodes || []).map(node => ({
          id: node.findingId || node.id,
          type: node.name || node.type,
          severity: node.severity || 'medium',
          description: node.description,
          file: node.file,
          technique: node.technique
        }));

        const response = await fetch(`${RED_TEAM_URL}/tools`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tool: 'bulk-validate',
            arguments: {
              findings: findings,
              maxConcurrent: 2
            }
          })
        });

        const data = await response.json();
        const results = data.result?.results || [];

        const exploitable = results.filter(r => r.exploitable).length;
        const validated = results.filter(r => r.validated).length;

        document.getElementById('simulationResults').innerHTML = `
          <div style="margin-bottom: 20px;">
            <div style="display: flex; gap: 16px; margin-bottom: 16px;">
              <div style="flex: 1; background: var(--bg-tertiary); padding: 16px; border-radius: 8px; text-align: center;">
                <div style="font-size: 28px; font-weight: bold; color: ${exploitable > 0 ? 'var(--critical)' : 'var(--success)'};">${exploitable}</div>
                <div style="font-size: 12px; color: var(--text-secondary);">Exploitable</div>
              </div>
              <div style="flex: 1; background: var(--bg-tertiary); padding: 16px; border-radius: 8px; text-align: center;">
                <div style="font-size: 28px; font-weight: bold; color: var(--accent);">${validated}</div>
                <div style="font-size: 12px; color: var(--text-secondary);">Validated</div>
              </div>
              <div style="flex: 1; background: var(--bg-tertiary); padding: 16px; border-radius: 8px; text-align: center;">
                <div style="font-size: 28px; font-weight: bold; color: var(--text-secondary);">${results.length - validated}</div>
                <div style="font-size: 12px; color: var(--text-secondary);">Theoretical</div>
              </div>
            </div>
            ${exploitable > 0 ? `
              <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid var(--critical); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                <strong style="color: var(--critical);">‚ö†Ô∏è Active Threat:</strong>
                <span style="color: var(--text-secondary);">This attack chain has ${exploitable} confirmed exploitable step(s).</span>
              </div>
            ` : `
              <div style="background: rgba(34, 197, 94, 0.1); border: 1px solid var(--success); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                <strong style="color: var(--success);">‚úÖ Low Risk:</strong>
                <span style="color: var(--text-secondary);">No steps in this chain were confirmed exploitable in your environment.</span>
              </div>
            `}
          </div>
          <div style="max-height: 300px; overflow-y: auto;">
            ${results.map((r, i) => `
              <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 8px;">
                <span style="width: 24px; height: 24px; border-radius: 50%; background: ${r.exploitable ? 'var(--critical)' : r.validated ? 'var(--warning)' : 'var(--text-muted)'}; display: flex; align-items: center; justify-content: center; font-size: 12px;">${i + 1}</span>
                <div style="flex: 1;">
                  <div style="font-weight: 500;">${r.finding?.type || findings[i]?.type || 'Unknown'}</div>
                  <div style="font-size: 12px; color: var(--text-secondary);">${r.reason || 'No details'}</div>
                </div>
                <span style="padding: 4px 8px; border-radius: 4px; font-size: 11px; background: ${r.exploitable ? 'var(--critical)' : r.validated ? 'var(--warning)' : 'var(--bg-secondary)'}; color: ${r.exploitable || r.validated ? 'white' : 'var(--text-secondary)'};">
                  ${r.exploitable ? 'EXPLOITABLE' : r.validated ? 'VALIDATED' : 'THEORETICAL'}
                </span>
              </div>
            `).join('')}
          </div>
        `;
      } catch (error) {
        document.getElementById('simulationResults').innerHTML = `
          <div style="text-align: center; padding: 40px; color: var(--critical);">
            <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
            <div>Simulation failed: ${error.message}</div>
          </div>
        `;
      }
    }
    window.simulateAttack = simulateAttack;

    async function generateReport(pathIndex) {
      const path = state.attackPaths[pathIndex];
      if (!path) {
        alert('Attack path not found. Please re-run the analysis.');
        return;
      }

      // Create modal for report
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';

      const nodes = path.nodes || [];
      const edges = path.edges || [];
      const techniques = path.mitreTechniques || [];

      const reportContent = `# Attack Path Report: ${path.name || 'Attack Chain'}

## Summary
- **Risk Level:** ${path.risk || path.severity || 'HIGH'}
- **Total Steps:** ${nodes.length}
- **Success Probability:** ${path.totalProbability || 'Unknown'}%
- **MITRE Techniques:** ${techniques.length > 0 ? techniques.join(', ') : 'None mapped'}

## Attack Narrative
${path.narrative || 'No narrative available.'}

## Attack Steps

${nodes.map((node, i) => `### Step ${i + 1}: ${node.name || node.type}
- **Type:** ${node.type || 'Unknown'}
- **Severity:** ${node.severity || 'medium'}
- **MITRE Technique:** ${node.technique || 'N/A'}
- **Description:** ${node.description || 'No description'}
${node.file ? `- **File:** ${node.file}` : ''}
`).join('\n')}

## Pivot Actions
${edges.map(edge => `- ${edge.action} (${edge.probability}% probability)`).join('\n') || 'No pivot actions recorded.'}

## Recommendations
1. Address the entry point vulnerability first (${nodes[0]?.name || 'first finding'})
2. Implement defense-in-depth to break the chain at multiple points
3. Monitor for indicators of compromise related to MITRE techniques: ${techniques.join(', ') || 'N/A'}

---
*Generated by Aura Security - Attack Path Analysis*
*Report Date: ${new Date().toISOString()}*`;

      modal.innerHTML = `
        <div class="modal-content" style="max-width: 800px;">
          <div class="modal-header">
            <h3>üìÑ Attack Path Report</h3>
            <div style="display: flex; gap: 8px;">
              <button onclick="navigator.clipboard.writeText(this.closest('.modal-content').querySelector('pre').textContent).then(() => alert('Copied to clipboard!'))" style="background: var(--accent); border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer;">üìã Copy</button>
              <button onclick="this.closest('.modal-overlay').remove()" style="background: none; border: none; color: var(--text-secondary); font-size: 24px; cursor: pointer;">&times;</button>
            </div>
          </div>
          <div class="modal-body">
            <pre style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px; overflow: auto; max-height: 500px; white-space: pre-wrap; font-size: 13px; line-height: 1.6;">${reportContent}</pre>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    window.generateReport = generateReport;

    // ========== RED TEAM AGENT INTEGRATION ==========
    // Red Team Agent: localhost uses port 4006, production uses nginx proxy at /redteam
    const RED_TEAM_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      ? 'http://localhost:4006'
      : `${window.location.origin}/redteam`;

    async function validateExploitability() {
      const repo = state.repos.find(r => r.id === state.selectedRepo);
      if (!repo || !repo.findings || repo.findings.length === 0) {
        alert('No findings to validate. Run a scan first.');
        return;
      }

      const container = document.getElementById('validationContent');
      const btn = document.getElementById('validateExploitBtn');

      btn.disabled = true;
      btn.textContent = '‚ö° Validating...';
      container.style.display = 'block';
      container.innerHTML = '<div style="text-align: center; padding: 20px;"><div class="loader"></div><br>Testing exploitability of findings...</div>';

      try {
        const response = await fetch(`${RED_TEAM_URL}/tools`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tool: 'bulk-validate',
            arguments: {
              findings: repo.findings.slice(0, 10), // Limit to first 10 for performance
              maxConcurrent: 3
            }
          })
        });

        const data = await response.json();
        const results = data.result?.results || data.result || [];

        if (results.length === 0) {
          container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">No validation results</div>';
        } else {
          container.innerHTML = `
            <div style="font-weight: 600; margin-bottom: 12px;">üéØ Exploitability Results</div>
            <div style="display: flex; flex-direction: column; gap: 8px;">
              ${results.map(r => {
                const exploitable = r.exploitable || r.isExploitable;
                const severity = exploitable ? 'critical' : 'success';
                const icon = exploitable ? '‚ö†Ô∏è' : '‚úÖ';
                return `
                  <div style="background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; padding: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span>${icon} ${r.finding?.type || r.findingType || 'Finding'}</span>
                      <span style="padding: 2px 8px; border-radius: 4px; font-size: 11px; background: var(--${severity}-subtle); color: var(--${severity});">
                        ${exploitable ? 'EXPLOITABLE' : 'NOT EXPLOITABLE'}
                      </span>
                    </div>
                    ${r.reason || r.explanation ? `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 6px;">${r.reason || r.explanation}</div>` : ''}
                    ${r.poc ? `<div style="font-size: 11px; color: var(--accent); margin-top: 4px;">POC Available</div>` : ''}
                  </div>
                `;
              }).join('')}
            </div>
          `;
        }

        btn.textContent = '‚ö° Validate Exploitability';
        btn.disabled = false;

      } catch (error) {
        console.error('Validation error:', error);
        container.innerHTML = `<div style="text-align: center; color: var(--critical); padding: 20px;">Error: ${error.message}</div>`;
        btn.textContent = '‚ö° Validate Exploitability';
        btn.disabled = false;
      }
    }
    window.validateExploitability = validateExploitability;

    // ========== FIXER AGENT INTEGRATION ==========
    // Fixer Agent: localhost uses port 3012, production uses nginx proxy at /fixer
    const FIXER_AGENT_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      ? 'http://localhost:3012'
      : `${window.location.origin}/fixer`;
    let currentFixesData = null;

    function showFixesSection(show) {
      document.getElementById('fixesSection').style.display = show ? 'block' : 'none';
    }

    async function generateFixes() {
      const repo = state.repos.find(r => r.id === state.selectedRepo);
      if (!repo || !repo.findings || repo.findings.length === 0) {
        showFixesError('No findings to generate fixes for');
        return;
      }

      const btn = document.getElementById('generateFixesBtn');
      const content = document.getElementById('fixesContent');

      // Show loading state
      btn.disabled = true;
      btn.textContent = 'Generating...';
      content.innerHTML = `
        <div class="fixes-loading">
          <div class="spinner"></div>
          <span>Connecting to Fixer Agent...</span>
        </div>
      `;

      try {
        // Convert findings to the format expected by Fixer Agent
        const findings = repo.findings.map(f => ({
          id: f.id || `finding-${Math.random().toString(36).substr(2, 9)}`,
          type: f.type === 'SECRET' ? 'secret' : f.type === 'VULN' ? 'vulnerability' : 'code-issue',
          severity: (f.severity || 'medium').toLowerCase(),
          title: f.title || f.message || f.description,
          description: f.description || f.message,
          file: f.file,
          line: f.line,
          package: f.package,
          version: f.version,
          cve: f.cve,
          cwe: f.cwe,
          metadata: f.metadata || {}
        }));

        const response = await fetch(`${FIXER_AGENT_URL}/tools`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tool: 'suggest-fixes-batch',
            arguments: { findings }
          })
        });

        if (!response.ok) {
          throw new Error(`Fixer Agent returned ${response.status}`);
        }

        const data = await response.json();
        currentFixesData = data.result;
        displayFixes(data.result);
      } catch (error) {
        console.error('Fixer Agent error:', error);
        showFixesError(error.message);
      } finally {
        btn.disabled = false;
        btn.textContent = 'Generate Fixes';
      }
    }
    window.generateFixes = generateFixes;

    function displayFixes(data) {
      const content = document.getElementById('fixesContent');

      if (!data || data.total === 0) {
        content.innerHTML = `
          <div class="empty-state" style="padding: 20px 0;">
            <div class="empty-state-icon">‚úì</div>
            <p>No fixes needed</p>
          </div>
        `;
        return;
      }

      // Summary stats
      let html = `
        <div class="fixes-summary">
          <div class="fixes-stat fixable">
            <span>‚úì</span> ${data.fixable} Fixable
          </div>
          <div class="fixes-stat unfixable">
            <span>‚úó</span> ${data.unfixable} Manual
          </div>
        </div>
      `;

      // Quick fix command
      if (data.allCommands && data.allCommands.length > 0) {
        const command = data.allCommands[0];
        html += `
          <div class="fix-command-box">
            <div class="fix-command-label">Quick Fix Command (click to copy)</div>
            <div class="fix-command" onclick="copyFixCommand()" style="cursor: pointer;" title="Click to copy">
              ${escapeHtml(command)}
            </div>
          </div>
        `;
      }

      // Version bump summary
      const versionBumps = data.fixes.filter(f => f.strategy === 'version-bump' && f.fixable);
      if (versionBumps.length > 0) {
        html += `
          <div class="filter-label" style="margin-bottom: 8px;">Package Updates (${versionBumps.length})</div>
          <div class="fix-list">
        `;

        // Show top 10 version bumps
        versionBumps.slice(0, 10).forEach(fix => {
          html += `
            <div class="fix-item">
              <span class="fix-icon">üì¶</span>
              <span class="fix-package">${fix.package || fix.finding?.package || 'unknown'}</span>
              <span class="fix-version">${fix.currentVersion || '?'}</span>
              <span class="fix-arrow">‚Üí</span>
              <span class="fix-new-version">${fix.fixedVersion || 'latest'}</span>
            </div>
          `;
        });

        if (versionBumps.length > 10) {
          html += `
            <div class="fix-item" style="color: var(--text-muted);">
              ... and ${versionBumps.length - 10} more
            </div>
          `;
        }

        html += '</div>';
      }

      // Other fixes summary
      const otherFixes = data.fixes.filter(f => f.strategy !== 'version-bump' && f.fixable);
      if (otherFixes.length > 0) {
        html += `
          <div class="filter-label" style="margin-top: 12px; margin-bottom: 8px;">Other Fixes (${otherFixes.length})</div>
          <div class="fix-list">
        `;

        otherFixes.slice(0, 5).forEach(fix => {
          const icon = fix.strategy === 'env-var' ? 'üîê' : fix.strategy === 'code-change' ? 'üîß' : 'üìù';
          html += `
            <div class="fix-item">
              <span class="fix-icon">${icon}</span>
              <span class="fix-package">${fix.description}</span>
            </div>
          `;
        });

        html += '</div>';
      }

      content.innerHTML = html;
    }

    function showFixesError(message) {
      const content = document.getElementById('fixesContent');
      const isConnectionError = message.includes('Failed to fetch') || message.includes('NetworkError');

      content.innerHTML = `
        <div class="fixes-error">
          <div class="fixes-error-title">${isConnectionError ? 'Fixer Agent Not Running' : 'Error'}</div>
          <div class="fixes-error-msg">${isConnectionError ? 'Start the Fixer Agent first:' : message}</div>
          ${isConnectionError ? '<code>npx tsx src/agents/slop/fixer-agent.ts</code>' : ''}
        </div>
      `;
    }

    function copyFixCommand() {
      if (!currentFixesData || !currentFixesData.allCommands || currentFixesData.allCommands.length === 0) return;

      const command = currentFixesData.allCommands[0];
      navigator.clipboard.writeText(command).then(() => {
        const commandEl = document.querySelector('.fix-command');
        const originalText = commandEl.textContent;
        commandEl.textContent = '‚úì Copied to clipboard!';
        commandEl.style.color = 'var(--success)';
        setTimeout(() => {
          commandEl.textContent = originalText;
          commandEl.style.color = '';
        }, 2000);
      });
    }
    window.copyFixCommand = copyFixCommand;

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ========== RUG CHECK ==========
    async function doRugCheck() {
      const urlInput = document.getElementById('rugcheckUrl');
      const btn = document.getElementById('rugcheckBtn');
      const resultsDiv = document.getElementById('rugcheckResults');
      const errorDiv = document.getElementById('rugcheckError');
      const gitUrl = urlInput.value.trim();

      if (!gitUrl) {
        errorDiv.innerHTML = 'Please enter a GitHub URL';
        errorDiv.style.display = 'block';
        resultsDiv.style.display = 'none';
        return;
      }

      // Validate URL format
      if (!gitUrl.includes('github.com')) {
        errorDiv.innerHTML = 'Only GitHub URLs are supported. Use format: https://github.com/owner/repo';
        errorDiv.style.display = 'block';
        resultsDiv.style.display = 'none';
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Checking...';
      errorDiv.style.display = 'none';
      resultsDiv.style.display = 'none';

      try {
        const response = await fetch(`${AURA_URL}/tools`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            tool: 'trust-scan',
            arguments: { gitUrl }
          })
        });

        const data = await response.json();
        console.log('[RugCheck] Raw response:', JSON.stringify(data, null, 2));
        console.log('[RugCheck] Response status:', response.status);
        console.log('[RugCheck] data.result exists:', !!data.result);
        const result = data.result || data;
        console.log('[RugCheck] Extracted result:', JSON.stringify(result, null, 2));
        console.log('[RugCheck] result.grade:', result.grade);
        console.log('[RugCheck] result.verdict:', result.verdict);

        if (result.error) {
          throw new Error(result.error);
        }

        console.log('[RugCheck] Calling renderRugCheckResults...');
        renderRugCheckResults(result);
        console.log('[RugCheck] renderRugCheckResults completed');
        resultsDiv.style.display = 'block';
      } catch (err) {
        console.error('Rug Check error:', err);
        errorDiv.innerHTML = `Error: ${err.message || 'Failed to check project'}`;
        errorDiv.style.display = 'block';
      } finally {
        btn.disabled = false;
        btn.textContent = 'Check Project';
      }
    }
    window.doRugCheck = doRugCheck;

    function renderRugCheckResults(data) {
      console.log('[RugCheck v1.2.1] renderRugCheckResults called - BULLETPROOF VERSION');
      try {
        console.log('[RugCheck] Input data:', JSON.stringify(data));

        // BULLETPROOF: Extract with absolute safety
        let trustScore = 0;
        let grade = 'F';
        let verdict = 'UNKNOWN';
        let verdictEmoji = '';
        let summary = '';
        let checks = [];
        let metrics = {};

        try { trustScore = (data && typeof data.trustScore === 'number') ? data.trustScore : 0; } catch(e) { console.error('trustScore error:', e); }
        try { grade = (data && data.grade) ? String(data.grade) : 'F'; } catch(e) { console.error('grade error:', e); }
        try { verdict = (data && data.verdict) ? String(data.verdict) : 'UNKNOWN'; } catch(e) { console.error('verdict error:', e); }
        try { verdictEmoji = (data && data.verdictEmoji) ? String(data.verdictEmoji) : ''; } catch(e) { console.error('verdictEmoji error:', e); }
        try { summary = (data && data.summary) ? String(data.summary) : ''; } catch(e) { console.error('summary error:', e); }
        try { checks = (data && Array.isArray(data.checks)) ? data.checks : []; } catch(e) { console.error('checks error:', e); }
        try { metrics = (data && data.metrics) ? data.metrics : {}; } catch(e) { console.error('metrics error:', e); }

        console.log('[RugCheck] Extracted - grade:', grade, ', verdict:', verdict, ', score:', trustScore);

        // BULLETPROOF: Convert grade to lowercase safely
        let gradeLower = 'f';
        try {
          gradeLower = grade ? grade.toString().toLowerCase() : 'f';
        } catch(e) {
          console.error('grade toLowerCase error:', e);
          gradeLower = 'f';
        }

        // BULLETPROOF: Convert verdict to lowercase safely
        let verdictLower = 'unknown';
        try {
          verdictLower = verdict ? verdict.toString().toLowerCase().replace(/ /g, '-') : 'unknown';
        } catch(e) {
          console.error('verdict toLowerCase error:', e);
          verdictLower = 'unknown';
        }

        // Update score circle
        const scoreCircle = document.getElementById('trustScoreCircle');
        const scoreNumber = document.getElementById('trustScoreNumber');
        const scoreGrade = document.getElementById('trustScoreGrade');

        if (scoreNumber) scoreNumber.textContent = trustScore;
        if (scoreGrade) scoreGrade.textContent = grade;

        if (scoreCircle) {
          scoreCircle.className = 'trust-score-circle';
          scoreCircle.classList.add('grade-' + gradeLower);
        }

      // Update verdict banner
      const verdictBanner = document.getElementById('verdictBanner');
      const verdictText = document.getElementById('verdictText');

      if (verdictText) verdictText.textContent = verdictEmoji + ' ' + verdict;
      if (verdictBanner) {
        verdictBanner.className = 'verdict-banner';
        verdictBanner.classList.add(verdictLower);
      }

      // Update quick stats
      const quickStats = document.getElementById('quickStats');
      const good = checks.filter(c => c && c.status === 'good').length;
      const warn = checks.filter(c => c && c.status === 'warn').length;
      const bad = checks.filter(c => c && c.status === 'bad').length;
      const info = checks.filter(c => c && c.status === 'info').length;

      quickStats.innerHTML = `
        ${good > 0 ? `<div class="quick-stat good">‚úì ${good} Good</div>` : ''}
        ${warn > 0 ? `<div class="quick-stat warn">‚ö† ${warn} Warnings</div>` : ''}
        ${bad > 0 ? `<div class="quick-stat bad">‚úó ${bad} Red Flags</div>` : ''}
        ${info > 0 ? `<div class="quick-stat info">‚Ñπ ${info} Info</div>` : ''}
      `;

      // Update checks list
      const checksList = document.getElementById('checksList');
      const statusIcons = {
        good: '‚úì',
        warn: '‚ö†',
        bad: '‚úó',
        info: '‚Ñπ'
      };

      if (checksList) {
        checksList.innerHTML = checks.map(check => {
          if (!check) return '';
          const status = check.status || 'info';
          const name = check.name || 'Unknown';
          const explanation = check.explanation || '';
          return `
            <div class="check-item ${status}">
              <span class="check-icon">${statusIcons[status] || '‚Ä¢'}</span>
              <div class="check-content">
                <div class="check-name">${escapeHtml(name)}</div>
                <div class="check-explanation">${escapeHtml(explanation)}</div>
              </div>
            </div>
          `;
        }).join('');
      }

      // Update summary
      const summaryEl = document.getElementById('summaryText');
      if (summaryEl) summaryEl.textContent = summary || 'No summary available';

      // Update metrics grid
      const metricsGrid = document.getElementById('metricsGrid');
      const m = metrics;

      if (metricsGrid) {
        const ageDays = Number(m.repoAgeDays) || 0;
        const commits = Number(m.commitCount) || 0;
        const contributors = Number(m.contributorCount) || 0;
        const stars = Number(m.stars) || 0;
        const forks = Number(m.forks) || 0;
        const codeFiles = Number(m.codeFileCount) || 0;

        metricsGrid.innerHTML = `
          <div class="metric-card">
            <div class="metric-value">${ageDays < 365 ? ageDays + 'd' : Math.floor(ageDays / 365) + 'y'}</div>
            <div class="metric-label">Age</div>
          </div>
          <div class="metric-card">
            <div class="metric-value">${formatNumber(commits)}</div>
            <div class="metric-label">Commits</div>
          </div>
          <div class="metric-card">
            <div class="metric-value">${contributors}</div>
            <div class="metric-label">Contributors</div>
          </div>
          <div class="metric-card">
            <div class="metric-value">${formatNumber(stars)}</div>
            <div class="metric-label">Stars</div>
          </div>
          <div class="metric-card">
            <div class="metric-value">${formatNumber(forks)}</div>
            <div class="metric-label">Forks</div>
          </div>
          <div class="metric-card">
            <div class="metric-value">${codeFiles}</div>
            <div class="metric-label">Code Files</div>
          </div>
        `;
      }
      } catch (err) {
        console.error('[RugCheck] Error in renderRugCheckResults:', err);
        console.error('[RugCheck] Data that caused error:', data);
        throw err; // Re-throw to be caught by doRugCheck
      }
    }

    function formatNumber(num) {
      if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
      if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
      return num.toString();
    }

    // ========== INIT ==========
    initScene();
    refreshScore(); // Fetch initial score
    log('Ready to scan');
  </script>
</body>
</html>
